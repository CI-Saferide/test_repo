From caf77d94752c59854f5bb146c8d59427ece75c9d Mon Sep 17 00:00:00 2001
From: oshriy <oshriy@saferide.io>
Date: Tue, 12 Mar 2019 15:10:41 +0200
Subject: [PATCH] vsentry binary classifier patch

Signed-off-by: oshriy <oshriy@saferide.io>
---
 include/linux/init.h                     |    5 +
 include/uapi/linux/Kbuild                |    1 +
 include/uapi/linux/vsentry/Kbuild        |    4 +
 include/uapi/linux/vsentry/vsentry.h     |  126 ++
 include/uapi/linux/vsentry/vsentry_drv.h |   67 +
 init/main.c                              |    5 +
 security/Kconfig                         |    1 +
 security/Makefile                        |    2 +
 security/vsentry/Kconfig                 |   11 +
 security/vsentry/Makefile                |    3 +
 security/vsentry/vsentry_drv.c           |  451 ++++
 security/vsentry/vsentry_hooks.c         | 2484 ++++++++++++++++++++++
 security/vsentry/vsentry_internal.h      |   34 +
 security/vsentry/vsentry_mod.c           |  825 +++++++
 14 files changed, 4019 insertions(+)
 create mode 100644 include/uapi/linux/vsentry/Kbuild
 create mode 100644 include/uapi/linux/vsentry/vsentry.h
 create mode 100644 include/uapi/linux/vsentry/vsentry_drv.h
 create mode 100644 security/vsentry/Kconfig
 create mode 100644 security/vsentry/Makefile
 create mode 100644 security/vsentry/vsentry_drv.c
 create mode 100644 security/vsentry/vsentry_hooks.c
 create mode 100644 security/vsentry/vsentry_internal.h
 create mode 100644 security/vsentry/vsentry_mod.c

diff --git a/include/linux/init.h b/include/linux/init.h
index e30104ceb86d..a08162f14562 100644
--- a/include/linux/init.h
+++ b/include/linux/init.h
@@ -120,6 +120,11 @@ extern char __initdata boot_command_line[];
 extern char *saved_command_line;
 extern unsigned int reset_devices;
 
+#ifdef CONFIG_SECURITY_VSENTRY
+/* defined in security/vsentry/vsentry_mod.c */
+extern int vsentry_mod_init(void);
+#endif
+
 /* used by init/main.c */
 void setup_arch(char **);
 void prepare_namespace(void);
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index cd2be1c8e9fb..395a9d706460 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -22,6 +22,7 @@ header-y += netfilter_ipv4/
 header-y += netfilter_ipv6/
 header-y += usb/
 header-y += wimax/
+header-y += vsentry/
 
 genhdr-y += version.h
 
diff --git a/include/uapi/linux/vsentry/Kbuild b/include/uapi/linux/vsentry/Kbuild
new file mode 100644
index 000000000000..6b63a031fd38
--- /dev/null
+++ b/include/uapi/linux/vsentry/Kbuild
@@ -0,0 +1,4 @@
+# UAPI Header export list
+header-y += vsentry_drv.h
+header-y += vsentry.h
+
diff --git a/include/uapi/linux/vsentry/vsentry.h b/include/uapi/linux/vsentry/vsentry.h
new file mode 100644
index 000000000000..9651c06e7552
--- /dev/null
+++ b/include/uapi/linux/vsentry/vsentry.h
@@ -0,0 +1,126 @@
+/* Copyright (C) 2018 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __VSENTRY_H__
+#define __VSENTRY_H__
+
+#define VSENTRY_SUCCESS		0
+#define VSENTRY_ERROR 		-1
+#define VSENTRY_ALREADY_EXISTS 	-2
+#define VSENTRY_NONE_EXISTS 	-3
+#define VSENTRY_INVALID 	-4
+#define VSENTRY_BUSY 		-5
+
+/* the following should be used in act_bitmap. see vsentry_event_t */
+#define VSENTRY_ACTION_DROP 	(0)
+#define VSENTRY_ACTION_ALLOW 	(1<<0)
+#define VSENTRY_ACTION_LOG 	(1<<1)
+#define VSENTRY_ACTION_LEARN 	(1<<2)
+
+typedef enum {
+	VSENTRY_MODE_ENFORCE,
+	VSENTRY_MODE_PERMISSIVE,
+	VSENTRY_MODE_LEARN,
+	VSENTRY_MODE_TOTAL,
+} vsentry_mode_e;
+
+typedef enum {
+	VSENTRY_CLASIFFIER_INIT,
+	VSENTRY_REGISTER_PRINTF,
+	VSENTRY_CLASIFFIER_SET_MODE,
+	VSENTRY_CLASIFFIER_GET_MODE,
+	VSENTRY_PRINT_INFO,
+	VSENTRY_REMOVE_INODE,
+	VSENTRY_FILE_EVENT,
+	VSENTRY_IP_EVENT,
+	VSENTRY_CAN_EVENT,
+	VSENTRY_TOTAL_EVENT,
+} vsentry_ev_type_e;
+
+typedef enum {
+	DIR_IN,
+	DIR_OUT,
+	DIR_TOTAL,
+} dir_e;
+
+#define CAN_PAYLOAD_LEN 	64
+
+typedef struct __attribute__ ((packed, aligned(8))) {
+	unsigned int msg_id;
+	unsigned int if_index;
+} can_header_t;
+
+typedef struct __attribute__((packed, aligned(8))) {
+	can_header_t 		can_header;
+	unsigned char 		payload[CAN_PAYLOAD_LEN];
+	unsigned char 		payload_len;
+} can_event_t;
+
+typedef struct __attribute__((packed, aligned(8))) {
+	union {
+		unsigned int v4addr;
+	} saddr;
+
+	union {
+		unsigned int v4addr;
+	} daddr;
+
+	unsigned short 		dport;
+	unsigned short 		sport;
+	unsigned char 		ip_proto;
+	unsigned int 		len;
+} ip_event_t;
+
+/* file modes */
+#define FILE_MODE_READ 	1<<0
+#define FILE_MODE_WRITE	1<<1
+#define FILE_MODE_EXEC	1<<2
+
+/* file types */
+typedef enum {
+	FILE_TYPE_REG,
+	FILE_TYPE_SYSFS,
+	FILE_TYPE_PROCFS,
+	FILE_TYPE_TOTAL,
+} file_type_t;
+
+typedef struct __attribute__((packed, aligned(8))) {
+	unsigned int 	mode;
+	unsigned int 	filename_len;
+	unsigned int 	type;
+	unsigned long 	file_ino;
+	unsigned long 	ancestor_ino;
+	char 		*filename;
+} file_event_t;
+
+typedef struct __attribute__((packed, aligned(8))) {
+	unsigned int 	uid;
+	unsigned long 	exec_ino;
+	unsigned int 	kernel;
+	unsigned int 	exec_name_len;
+	char 		*exec_name;
+} id_event_t;
+
+typedef struct __attribute__((packed, aligned(8))) {
+	unsigned int	 	type;
+	unsigned int 		act_bitmap;
+	id_event_t 		event_id;
+	unsigned int 		dir;
+	unsigned long long 	ts;
+	union {
+		can_event_t 	can_event;
+		ip_event_t 	ip_event;
+		file_event_t 	file_event;
+	};
+} vsentry_event_t;
+
+#endif /* __VSENTRY_H__ */
diff --git a/include/uapi/linux/vsentry/vsentry_drv.h b/include/uapi/linux/vsentry/vsentry_drv.h
new file mode 100644
index 000000000000..c6eed03e991e
--- /dev/null
+++ b/include/uapi/linux/vsentry/vsentry_drv.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 2018 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __VSENTRY_DRV_H__
+#define __VSENTRY_DRV_H__
+
+#define VSENTRY_GENL_FAMILY_NAME 	"vsentry_event"
+#define VSENTRY_GENL_VERSION 		0x01
+#define VSENTRY_GENL_MCAST_GROUP_NAME 	"vsentry_mc_grp"
+
+enum {
+        VSENTRY_GENL_ATTR_UNSPEC,
+        VSENTRY_GENL_ATTR_EVENT,
+        VSENTRY_GENL_ATTR_LAST,
+};
+#define VSENTRY_GENL_ATTR_MAX (VSENTRY_GENL_ATTR_LAST - 1)
+
+enum {
+        VSENTRY_GENL_CMD_UNSPEC,
+        VSENTRY_GENL_CMD_EVENT,
+        VSENTRY_GENL_CMD_LAST,
+};
+#define VSENTRY_GENL_CMD_MAX (VSENTRY_GENL_CMD_LAST - 1)
+
+/* mmap address mapping 8MB sheard memory buffer */
+#define SHMEM_BUFFER_SIZE 	0x800000
+#define SHMEM_BUFFER_OFFSET 	0
+
+struct vsentry_state {
+	unsigned int enabled;
+	unsigned int mode;
+	unsigned int cls_present;
+	unsigned int db_present;
+	unsigned int file_cls_mode;
+};
+
+struct vsentry_genl_info {
+	unsigned int family;
+	unsigned int mcgrp;
+};
+
+typedef enum {
+	FILE_CLS_MODE_STR,
+	FILE_CLS_MODE_INODE,
+	FILE_CLS_MODE_MAX,
+} vsentry_file_cls_mode;
+
+#define VSENTRY_IOCTL_SET_ENABLE 	_IOW('v', 0x01, unsigned int)
+#define VSENTRY_IOCTL_UPDATE_EXECFILE 	_IOW('v', 0x02, char *)
+#define VSENTRY_IOCTL_UPDATE_DBFILE 	_IOW('v', 0x03, char *)
+#define VSENTRY_IOCTL_SET_MODE 		_IOW('v', 0x04, unsigned int)
+#define VSENTRY_IOCTL_GET_STATE 	_IOR('v', 0x05, struct vsentry_state)
+#define VSENTRY_IOCTL_GET_GENL_INFO 	_IOR('v', 0x06, struct vsentry_genl_info)
+#define VSENTRY_IOCTL_PRINT_INFO 	_IO( 'v', 0x07)
+#define VSENTRY_IOCTL_COPY_DBFILE 	_IOW('v', 0x08, char *)
+#define VSENTRY_IOCTL_FILE_CLS_MODE 	_IOW('v', 0x09, unsigned int)
+
+#endif /* __VSENTRY_DRV_H__ */
diff --git a/init/main.c b/init/main.c
index 2858be732f6d..15d021abcef1 100644
--- a/init/main.c
+++ b/init/main.c
@@ -952,6 +952,11 @@ static int __ref kernel_init(void *unused)
 
 	rcu_end_inkernel_boot();
 
+#ifdef CONFIG_SECURITY_VSENTRY
+	/* init vsentry security */
+	vsentry_mod_init();
+#endif
+
 	if (ramdisk_execute_command) {
 		ret = run_init_process(ramdisk_execute_command);
 		if (!ret)
diff --git a/security/Kconfig b/security/Kconfig
index 118f4549404e..a833bbd89330 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -164,6 +164,7 @@ source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/vsentry/Kconfig
 
 source security/integrity/Kconfig
 
diff --git a/security/Makefile b/security/Makefile
index f2d71cdb8e19..7e00b43bac9d 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -9,6 +9,7 @@ subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin
+subdir-$(CONFIG_SECURITY_VSENTRY)       += vsentry
 
 # always enable default capabilities
 obj-y					+= commoncap.o
@@ -24,6 +25,7 @@ obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
+obj-$(CONFIG_SECURITY_VSENTRY)		+= vsentry/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
 # Object integrity file lists
diff --git a/security/vsentry/Kconfig b/security/vsentry/Kconfig
new file mode 100644
index 000000000000..1cb60f4ee8d7
--- /dev/null
+++ b/security/vsentry/Kconfig
@@ -0,0 +1,11 @@
+config SECURITY_VSENTRY
+	bool "SafeRide's vSentry security Kernel Support"
+	depends on SECURITY
+	select SECURITY_NETWORK
+	select SECURITY_NETWORK_XFRM
+	select SECURITY_PATH
+	select NETFILTER
+	default y
+	help
+	  This selects the SafeRide's vSentry security.
+
diff --git a/security/vsentry/Makefile b/security/vsentry/Makefile
new file mode 100644
index 000000000000..2154a7b6a9a7
--- /dev/null
+++ b/security/vsentry/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SECURITY_VSENTRY) := vsentry.o
+
+vsentry-y := vsentry_drv.o vsentry_mod.o vsentry_hooks.o
diff --git a/security/vsentry/vsentry_drv.c b/security/vsentry/vsentry_drv.c
new file mode 100644
index 000000000000..b4dee85264d5
--- /dev/null
+++ b/security/vsentry/vsentry_drv.c
@@ -0,0 +1,451 @@
+/* Copyright (C) 2018 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/reboot.h>
+#include <linux/uaccess.h>
+#include <net/genetlink.h>
+#include <linux/vsentry/vsentry.h>
+#include <linux/vsentry/vsentry_drv.h>
+#include "vsentry_internal.h"
+
+static volatile bool used;
+static dev_t vsentry_dev;
+static struct cdev *cdev_p;
+
+static const struct genl_multicast_group vsentry_event_mcgrps[] = {
+	{ .name = VSENTRY_GENL_MCAST_GROUP_NAME, },
+};
+
+static struct genl_family vsentry_event_genl_family = {
+	.id = GENL_ID_GENERATE,
+	.name = VSENTRY_GENL_FAMILY_NAME,
+	.version = VSENTRY_GENL_VERSION,
+	.maxattr = VSENTRY_GENL_ATTR_MAX,
+	.mcgrps = vsentry_event_mcgrps,
+	.n_mcgrps = ARRAY_SIZE(vsentry_event_mcgrps),
+};
+
+#define VS_DRV_DEBUG
+#ifdef VS_DRV_DEBUG
+#define vs_drv_debug(fmt, ...) \
+	pr_debug("[DBG] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#else
+#define vs_drv_debug(...)
+#endif
+
+#define vs_drv_info(fmt, ...) \
+	pr_info("[INF] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+
+#define vs_drv_err(fmt, ...) \
+	pr_err("[ERR] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+
+/***********************************************************************
+ * function:    vsentry_drv_release
+ * description: close device
+ * in param:    struct inode *inode
+ *              struct file *file
+ * out param:   n/a.
+ * return:      0 on success.
+ **********************************************************************/
+static int vsentry_drv_release(struct inode *inode, struct file *file)
+{
+	vsentry_set_eng_tgid(0);
+	used = false;
+	vs_drv_debug("driver closed\n");
+	return 0;
+}
+
+/***********************************************************************
+ * function:    vsentry_drv_open
+ * description: open device
+ * in param:    struct inode *inode
+ *              struct file *file
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static int vsentry_drv_open(struct inode *inode, struct file *file)
+{
+	vs_drv_debug("\n");
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (used) {
+		vs_drv_err("already in use\n");
+		return -EBUSY;
+	}
+
+	/* TODO: check if the opening process is authorized */
+
+	used = true;
+
+	/* register the engine pid */
+	if (vsentry_set_eng_tgid(current->tgid) != VSENTRY_SUCCESS) {
+		vs_drv_err("failed to set new tgid\n");
+		return -EPERM;
+	}
+
+	vs_drv_debug("used by tgid %d\n", vsentry_get_eng_tgid());
+
+	return 0;
+}
+
+/***********************************************************************
+ * function:    vsentry_drv_ioctl
+ * description: open device
+ * in param:    struct file *file
+ *              u32 cmd
+ *              unsigned long arg
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static long vsentry_drv_ioctl(struct file *file, u32 cmd, unsigned long arg)
+{
+	int ret = 0;
+	char *file_str;
+
+	switch (cmd) {
+	case VSENTRY_IOCTL_SET_ENABLE:
+	{
+		u32 enable;
+
+		vs_drv_debug("set enable\n");
+		if (get_user(enable, (u32 __user *) arg))
+			return -EFAULT;
+
+		if (enable != true && enable != false)
+			return -EINVAL;
+
+		ret = vsentry_set_enable(enable);
+		break;
+	}
+
+	case VSENTRY_IOCTL_UPDATE_EXECFILE:
+	{
+		vs_drv_debug("set execfile\n");
+		file_str = strndup_user((void __user *) arg, PAGE_SIZE);
+		if (IS_ERR(file_str)) {
+			ret = PTR_ERR(file_str);
+			break;
+		}
+
+		ret = vsentry_update_execmem(file_str);
+		kfree(file_str);
+
+		break;
+	}
+
+	case VSENTRY_IOCTL_UPDATE_DBFILE:
+	{
+		vs_drv_debug("update dbfile\n");
+		file_str = strndup_user((void __user *)arg, PAGE_SIZE);
+		if (IS_ERR(file_str)) {
+			ret = PTR_ERR(file_str);
+			break;
+		}
+
+		ret = vsentry_update_shmem(file_str);
+		kfree(file_str);
+
+		break;
+	}
+
+	case VSENTRY_IOCTL_SET_MODE:
+	{
+		u32 mode;
+
+		vs_drv_debug("set mode\n");
+		if (get_user(mode, (u32 __user *) arg))
+			return -EFAULT;
+
+		if (mode >= VSENTRY_MODE_TOTAL)
+			return -EINVAL;
+
+		ret = vsentry_set_mode(mode);
+		break;
+	}
+
+	case VSENTRY_IOCTL_GET_STATE:
+	{
+		struct vsentry_state state;
+		void __user *argp = (void __user *)arg;
+
+		vs_drv_debug("get state\n");
+		ret = vsentry_get_state(&state);
+		if (ret == VSENTRY_SUCCESS) {
+			if (copy_to_user(argp, &state, sizeof(struct vsentry_state)))
+				ret = -EFAULT;
+		}
+		break;
+	}
+
+	case VSENTRY_IOCTL_GET_GENL_INFO:
+	{
+		struct vsentry_genl_info info;
+		void __user *argp = (void __user *)arg;
+
+		vs_drv_debug("get genl info\n");
+		if (vsentry_event_genl_family.id == GENL_ID_GENERATE)
+			return -ENOENT;
+
+		info.family = vsentry_event_genl_family.id;
+		info.mcgrp = vsentry_event_genl_family.mcgrp_offset;
+
+		if (copy_to_user(argp, &info, sizeof(struct vsentry_genl_info)))
+			ret = -EFAULT;
+
+		break;
+	}
+
+	case VSENTRY_IOCTL_PRINT_INFO:
+		vsentry_print_info();
+		break;
+
+	case VSENTRY_IOCTL_COPY_DBFILE:
+		vs_drv_debug("copy dbfile\n");
+		file_str = strndup_user((void __user *)arg, PAGE_SIZE);
+		if (IS_ERR(file_str)) {
+			ret = PTR_ERR(file_str);
+			break;
+		}
+
+		ret = vsentry_copy_shmem(file_str);
+		kfree(file_str);
+
+		break;
+
+	case VSENTRY_IOCTL_FILE_CLS_MODE:
+	{
+		u32 file_cls_mode;
+
+		vs_drv_debug("set cls mode\n");
+		if (get_user(file_cls_mode, (u32 __user *) arg))
+			return -EFAULT;
+
+		if (file_cls_mode >= FILE_CLS_MODE_MAX)
+			return -EINVAL;
+
+		ret = vsentry_set_file_cls_mode(file_cls_mode);
+		break;
+	}
+
+	default:
+		vs_drv_err("error\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct file_operations vsentry_file_ops = {
+	.owner = THIS_MODULE,
+	.open = vsentry_drv_open,
+	.unlocked_ioctl = vsentry_drv_ioctl,
+	.release = vsentry_drv_release,
+};
+
+/***********************************************************************
+ * function:    vsentry_drv_file_ops_init
+ * description: initialize and register the file ops
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static int vsentry_drv_file_ops_init(void)
+{
+	int ret = 0;
+	struct class *vsentry_class;
+
+	vs_drv_debug("\n");
+
+	ret = alloc_chrdev_region(&vsentry_dev, 0, 1, "vs_drv");
+	if (ret < 0) {
+		vs_drv_err("couldn't allocate device number (%d).\n", ret);
+		goto out;
+	}
+
+	ret = -ENOMEM;
+	cdev_p = cdev_alloc();
+	if (!cdev_p) {
+		vs_drv_err("failed to alloc cdev\n");
+		goto out_unregister;
+	}
+
+	cdev_p->owner = THIS_MODULE;
+	cdev_p->ops = &vsentry_file_ops;
+	ret = cdev_add(cdev_p, vsentry_dev, 1);
+	if (ret) {
+		vs_drv_err("couldn't add character device (%d)\n", ret);
+		goto free_cdev;
+	}
+
+	/* create /dev/vs_drv */
+	vsentry_class = class_create(THIS_MODULE, "vsentry");
+	if (IS_ERR(vsentry_class)) {
+		vs_drv_err("failed creating vsentry class\n");
+		goto free_cdev;
+	}
+
+	device_create(vsentry_class, NULL, vsentry_dev, NULL, "vs_drv");
+
+	return 0;
+
+free_cdev:
+	cdev_del(cdev_p);
+out_unregister:
+	unregister_chrdev_region(vsentry_dev, 1);
+out:
+	return ret;
+}
+
+/***********************************************************************
+ * function:    vsentry_drv_file_ops_deinit
+ * description: deinitialize and deregister the file ops
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static void vsentry_drv_file_ops_deinit(void)
+{
+	vs_drv_debug("\n");
+	cdev_del(cdev_p);
+	unregister_chrdev_region(vsentry_dev, 1);
+	cdev_p = NULL;
+}
+
+/***********************************************************************
+ * function:    vsentry_generate_netlink_event
+ * description: send vsentry event over netlink
+ * in param:    vsentry_event_t *ev
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+int vsentry_generate_netlink_event(vsentry_event_t *ev)
+{
+	struct sk_buff *skb;
+	struct nlattr *attr;
+	void *msg_header;
+	struct vsentry_event_t *genl_ev;
+	int size;
+	static unsigned int event_seqnum;
+
+	if (!ev)
+		return -EINVAL;
+
+	size = nla_total_size(sizeof(vsentry_event_t)) + nla_total_size(0);
+	skb = genlmsg_new(size, GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+
+	msg_header = genlmsg_put(skb, 0, event_seqnum++,
+			&vsentry_event_genl_family, 0, VSENTRY_GENL_CMD_EVENT);
+	if (!msg_header) {
+		nlmsg_free(skb);
+		return -ENOMEM;
+	}
+
+	/* fill the data */
+	attr = nla_reserve(skb, VSENTRY_GENL_ATTR_EVENT, sizeof(vsentry_event_t));
+	if (!attr) {
+		nlmsg_free(skb);
+		return -EINVAL;
+	}
+
+	genl_ev = nla_data(attr);
+	if (!genl_ev) {
+		nlmsg_free(skb);
+		return -EINVAL;
+	}
+
+	memcpy(genl_ev, ev, sizeof(vsentry_event_t));
+	genlmsg_end(skb, msg_header);
+	genlmsg_multicast(&vsentry_event_genl_family, skb, 0, 0, GFP_ATOMIC);
+
+	return 0;
+}
+
+/***********************************************************************
+ * function:    vsentry_reboot
+ * description: callback function to be called upon system reboot/halt
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+//static int vsentry_reboot(struct notifier_block *nb, unsigned long event, void *unused)
+//{
+//	vsentry_shutdown();
+//        return NOTIFY_DONE;
+//}
+//
+//static struct notifier_block vsentry_reboot_notifier = {
+//        .notifier_call = vsentry_reboot,
+//};
+/***********************************************************************
+ * function:    vsentry_drv_init
+ * description: driver registeration
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static int __init vsentry_drv_init(void)
+{
+	int ret;
+
+	ret = vsentry_drv_file_ops_init();
+	if (ret) {
+		vs_drv_err("failed\n");
+		return ret;
+	}
+
+	ret = genl_register_family(&vsentry_event_genl_family);
+	if (ret != 0) {
+		pr_err("genl_register_family failed\n");
+		return ret;
+	}
+
+	/* add ourselves to the reboot_notifier_list */
+//	ret = register_reboot_notifier(&vsentry_reboot_notifier);
+//	if (ret != 0)
+//		pr_warn("can't register reboot notifier\n");
+
+
+	vs_drv_info("saferide's vsentry driver interface initialized\n");
+
+	return 0;
+}
+
+/***********************************************************************
+ * function:    vsentry_drv_exit
+ * description: driver rdeegisteration
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+static void __exit vsentry_drv_exit(void)
+{
+	genl_unregister_family(&vsentry_event_genl_family);
+	vsentry_drv_file_ops_deinit();
+}
+
+device_initcall(vsentry_drv_init);
+__exitcall(vsentry_drv_exit);
diff --git a/security/vsentry/vsentry_hooks.c b/security/vsentry/vsentry_hooks.c
new file mode 100644
index 000000000000..6f2127945752
--- /dev/null
+++ b/security/vsentry/vsentry_hooks.c
@@ -0,0 +1,2484 @@
+/* Copyright (C) 2019 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/fsnotify_backend.h>
+#include <linux/lsm_hooks.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/mutex.h>
+#include <linux/magic.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/sock.h>
+#include <linux/can/core.h>
+#include <linux/can/skb.h>
+#include <linux/binfmts.h>
+
+#include <linux/vsentry/vsentry.h>
+#include <linux/vsentry/vsentry_drv.h>
+#include "vsentry_internal.h"
+
+//#define VS_HOOK_DEBUG
+#ifdef VS_HOOK_DEBUG
+#define vs_hook_dbg(fmt, ...) \
+	pr_dbg("[DBG] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#else
+#define vs_hook_dbg(...)
+#endif /* VS_MOD_DEBUG */
+
+#define vs_hook_err(fmt, ...) \
+	pr_err("[ERR] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#define vs_hook_warn(fmt, ...) \
+	pr_warn("[WRN] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#define vs_hook_info(fmt, ...) \
+	pr_info("[INF] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+
+#define free_name(x) __putname((uintptr_t)x & ~(PATH_MAX-1))
+
+#define NUM_OF_BUCKETS_BITS	8
+#define MAP_SIZE		(1 << NUM_OF_BUCKETS_BITS)
+
+/* super block type to vsentry file type mapping.
+ * on each registered mount we keep the mapping to vsentry file type
+ * see vsentry_sb_kern_mount */
+static struct hlist_head super_block_map[MAP_SIZE];
+static DEFINE_SPINLOCK(super_block_map_lock);
+
+struct sb_to_vsentry_t {
+	unsigned long		s_magic;
+	unsigned int 		vsentry_type;
+	struct hlist_node	node;
+};
+
+/***********************************************************************
+ * function:     get_file_type_by_magic
+ * description:  get the s_maginc mapping to vsentry file type.
+ * in param:     unsigned long s_magic - super block magic number.
+ * out param:    n/a.
+ * return:       unsigned int vsentry_type;
+ **********************************************************************/
+static int get_file_type_by_magic(unsigned long s_magic)
+{
+	struct sb_to_vsentry_t *s2v = NULL;
+	struct hlist_node *n;
+	unsigned char hash = hash_32(s_magic, NUM_OF_BUCKETS_BITS);
+	int ret = FILE_TYPE_REG;
+
+	spin_lock(&super_block_map_lock);
+
+	hlist_for_each_entry_safe(s2v, n, &super_block_map[hash], node) {
+		if (s2v->s_magic == s_magic) {
+			vs_hook_dbg("found sb 0x%lx vsentry type %u\n", s2v->s_magic, s2v->vsentry_type);
+			ret = s2v->vsentry_type;
+			break;
+		}
+	}
+
+	spin_unlock(&super_block_map_lock);
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     get_full_path
+ * description:  get the full path from struct path *path
+ * in param:     const struct path *path - path structure of a file.
+  *               int size - buffer size
+ * out param:    char *path_buffer - place to hold the path.
+ * return:       char *. NULL if error. pointer to start of path.
+ **********************************************************************/
+static inline char *get_full_path(const struct path *path, char *path_buffer, int size)
+{
+	char *path_ptr = NULL;
+
+	/* get the full path from *path */
+	path_ptr = d_absolute_path(path, path_buffer, size);
+	if (IS_ERR(path_ptr)) {
+		vs_hook_err("d_absolute_path failed\n");
+		return NULL;
+	}
+
+	return path_ptr;
+}
+
+/***********************************************************************
+ * function:     vsentry_get_pid_exec_path
+ * description:  extract the executable path of specific pid
+ * in param:     unsigned int pid - process pid
+ * out param:    id_event_t *id - info place holder.
+ * return:       n/a
+ **********************************************************************/
+static inline void vsentry_get_pid_exec_path(unsigned int pid, id_event_t *id)
+{
+	struct task_struct *p;
+	char *path_buffer = NULL;
+
+	if (!pid || !id) {
+		vs_hook_err("no pid or id\n");
+		goto exit_get_pid_path;
+	}
+
+	rcu_read_lock();
+
+	p = pid_task(find_vpid(pid), PIDTYPE_PID);
+	if (!p) {
+		vs_hook_err("cant find pid %u\n", pid);
+		goto exit_get_pid_path;
+	}
+
+	if ((p->flags & PF_KTHREAD) || !p->mm || !p->mm->exe_file) {
+		/* in kernel code, no file can be extracted so just mark as kernel */
+		id->kernel = true;
+		id->uid = 0;
+		id->exec_name = NULL;
+		goto exit_get_pid_path;
+	}
+
+	path_buffer = __getname();
+	if (!path_buffer) {
+		vs_hook_err("failed to allocate path buffer\n");
+		goto exit_get_pid_path;
+	}
+
+	id->kernel = false;
+	id->exec_name = get_full_path(&p->mm->exe_file->f_path, path_buffer, PATH_MAX);
+	if (id->exec_name) {
+		id->exec_name_len = strlen(id->exec_name);
+	} else {
+		vs_hook_err("failed to get exec_name\n");
+		__putname(path_buffer);
+		id->exec_name_len = 0;
+	}
+
+exit_get_pid_path:
+	rcu_read_unlock();
+}
+
+/***********************************************************************
+ * function:     vsentry_get_pid_exec_inode
+ * description:  extract the executable inode of specific pid
+ * in param:     unsigned int pid - process pid
+ * out param:    n/a
+ * return:       unsigned long - inode
+ **********************************************************************/
+static unsigned long vsentry_get_pid_exec_inode(unsigned int pid)
+{
+	struct task_struct *p;
+	struct mm_struct *mm;
+	struct file *exe_file;
+	unsigned int ret = 0;
+
+	if (!pid)
+		return 0;
+
+	p = pid_task(find_vpid(pid), PIDTYPE_PID);
+	if (!p)
+		goto exit_err;
+
+	mm = p->mm;
+	if (!mm)
+		goto exit_err;
+
+	exe_file = mm->exe_file;
+	if (!exe_file)
+		goto exit_err;
+
+	ret = exe_file->f_path.dentry->d_inode->i_ino;
+
+exit_err:
+	return ret;
+}
+
+/***********************************************************************
+ * function:     vsentry_get_current_info
+ * description:  get the current uid and exec_ino
+ * in param:     n/a
+ * out param:    id_event_t *id
+ * return:       n/a
+ **********************************************************************/
+static inline void vsentry_get_current_info(id_event_t *id)
+{
+	rcu_read_lock();
+
+	if (current->flags & PF_KTHREAD) {
+		/* in kernel code, no file can be extracted so just mark
+		 * as kernel */
+		id->kernel = true;
+		id->uid = 0;
+		id->exec_ino = 0;
+	} else {
+		id->kernel = false;
+		id->exec_ino = vsentry_get_pid_exec_inode(current->pid);
+		id->uid = current->real_cred->uid.val;
+	}
+
+	rcu_read_unlock();
+}
+
+/***********************************************************************
+ * function:     vsentry_get_full_path
+ * description:  helper function that return the full path of a
+ *               file/directory extracted from struct path
+ * in param:     const struct path *path - path structure.
+ * out param:    file_event_t *file_ev - fil event struct to fill
+ * return:       VSENTRY_ERROR/VSENTRY_SUCCESS/VSENTRY_ALREADY_EXISTS
+ **********************************************************************/
+static int vsentry_get_full_path(const struct path *path, file_event_t *file_ev)
+{
+	char *path_buffer = NULL;
+
+	path_buffer = __getname();
+	if (!path_buffer) {
+		vs_hook_err("failed to allocate path buffer\n");
+		return VSENTRY_ERROR;
+	}
+
+	/* get the full path from current */
+	file_ev->filename = get_full_path(path, path_buffer, PATH_MAX);
+	if (!file_ev->filename) {
+		/* we were not able to extract the current path */
+		__putname(path_buffer);
+		file_ev->filename = NULL;
+		return VSENTRY_ERROR;
+	}
+
+	file_ev->filename_len = strlen(file_ev->filename);
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:     vsentry_check_self_proc
+ * description:  this function check if the current process try to
+ *               access its own proc directory.
+ * in param:     const struct path *path.
+ * out param:    n/a.
+ * return:       VSENTRY_ALREADY_EXISTS - current process try to
+ *                                        access its own proc.
+ *               VSENTRY_SUCCESS - current access some other proc file
+ **********************************************************************/
+static inline int vsentry_check_self_proc(const struct path *path)
+{
+	char current_proc_name[256];
+	struct dentry *dentry = path->dentry;
+	struct dentry *parent = dentry->d_parent;
+
+	/* go up the path till hit root (/proc) */
+	while(parent->d_parent != parent) {
+		dentry = parent;
+		parent = parent->d_parent;
+	}
+
+	/* check if this is current (with pid PID) access /proc/PID/xxx */
+	snprintf(current_proc_name, 256, "%d", current->pid);
+	if (strcmp(current_proc_name, dentry->d_name.name) == 0)
+		return VSENTRY_ALREADY_EXISTS;
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:     vsentry_handle_file_event
+ * description:  general function that handle all file event
+ * in param:     const struct path *path - path structure.
+ * out param:    unsigned int mode - file mode
+ * return:       char *. NULL error
+ **********************************************************************/
+static inline int vsentry_handle_file_event(const struct path *path, unsigned int mode)
+{
+	vsentry_event_t ev;
+	int ret = 0;
+
+	if (!vsentry_get_enable())
+		return 0;
+
+	memset(&ev, 0, sizeof(vsentry_event_t));
+
+	/* get common info */
+	vsentry_get_current_info(&ev.event_id);
+	ev.ts = vsentry_get_curr_time_usec();
+	ev.dir = DIR_IN;
+	ev.file_event.mode = mode;
+	ev.file_event.type = get_file_type_by_magic(path->dentry->d_sb->s_magic);
+
+	if (vsentry_get_file_cls_mode() == FILE_CLS_MODE_STR)
+		/* get the executable full path */
+		vsentry_get_pid_exec_path(current->pid, &ev.event_id);
+
+	if (ev.file_event.type != FILE_TYPE_REG) {
+		/* proc/sys files handling */
+		if (ev.file_event.type == FILE_TYPE_PROCFS) {
+			ret = vsentry_check_self_proc(path);
+			if (ret == VSENTRY_ALREADY_EXISTS)
+				/* the current process access its own /proc/PID dir */
+				return 0;
+		}
+
+		/* if SYS/PROC files we dont need to extract other info */
+		ev.file_event.filename = NULL;
+		ev.file_event.filename_len = 0;
+
+		if (vsentry_check_event(VSENTRY_FILE_EVENT, &ev, false) != VSENTRY_SUCCESS)
+			return -EACCES;
+
+		return 0;
+	}
+
+	if (vsentry_get_file_cls_mode() == FILE_CLS_MODE_STR) {
+		/* get the file full path from struct path */
+		ret = vsentry_get_full_path(path, &ev.file_event);
+		if (ret != VSENTRY_SUCCESS) {
+			ret = -EACCES;
+			goto handle_file_event_exit;
+		}
+
+		/* in string mode we only classify the event once as we
+		 * have the full path */
+		if (vsentry_check_event(VSENTRY_FILE_EVENT, &ev, false) != VSENTRY_SUCCESS)
+			ret = -EACCES;
+	} else {
+		struct dentry *ancestor= path->dentry->d_parent;
+
+		/* case of inode mode, we try to check the inode "recursively" till
+		 * we get "allow" or hit the root and return with -EACCESS */
+		ev.file_event.file_ino = path->dentry->d_inode->i_ino;
+
+		do {
+			ev.file_event.ancestor_ino = ancestor->d_inode->i_ino;
+
+			ret = vsentry_check_event(VSENTRY_FILE_EVENT, &ev, false);
+			if (ret == VSENTRY_NONE_EXISTS)
+				ancestor = ancestor->d_parent;
+			else
+				break;
+		} while(ancestor != ancestor->d_parent);
+
+		if (ret != VSENTRY_SUCCESS)
+			ret = -EACCES;
+	}
+
+handle_file_event_exit:
+	if (ev.event_id.exec_name)
+		free_name(ev.event_id.exec_name);
+
+	if (ev.file_event.filename)
+		free_name(ev.file_event.filename);
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     vsentry_extract_ip_info
+ * description:  extract L3 (IP) info from skb
+ * in param:     struct sk_buff *skb
+ * out param:    ip_event_t *ip_event
+ * return:       n/a
+ **********************************************************************/
+static void vsentry_extract_ip_info(ip_event_t *ip_event, struct sk_buff *skb)
+{
+	struct iphdr *ip_header = (struct iphdr *)skb_network_header(skb);
+
+	ip_event->daddr.v4addr = ntohl(ip_header->daddr);
+	ip_event->saddr.v4addr = ntohl(ip_header->saddr);
+
+	if (ip_header->protocol == IPPROTO_TCP) {
+		struct tcphdr *tcphdr =
+			(struct tcphdr *)skb_transport_header(skb);
+
+		ip_event->sport = ntohs(tcphdr->source);
+		ip_event->dport = ntohs(tcphdr->dest);
+		ip_event->len = ntohs(ip_header->tot_len) -
+			(ip_header->ihl * 4) - (tcphdr->doff * 4);
+	} else {
+		struct udphdr *udp_header =
+			(struct udphdr *)skb_transport_header(skb);
+
+		ip_event->sport = ntohs(udp_header->source);
+		ip_event->dport = ntohs(udp_header->dest);
+		ip_event->len = ntohs(udp_header->len) - sizeof(struct udphdr);
+	}
+}
+
+/* the code below manage the mapping between socket and exec_inode.
+ * upon socket creation, a mapping is added between the creating process
+ * and the socket. upon socet deletion the mapping is removed.
+ */
+
+/* socket to process/uid mapping */
+static struct hlist_head socket_process_map[MAP_SIZE];
+static DEFINE_SPINLOCK(socket_process_map_lock);
+
+struct socket_to_id_t {
+	struct socket		*socket;
+	struct inode		*inode;
+	int 			pid;
+	id_event_t		id;
+};
+
+struct s2p_node_t {
+	struct socket_to_id_t 	s2p;
+	struct hlist_node	list;
+	struct rcu_head         rhead;
+};
+
+/***********************************************************************
+ * function:     map_process_to_socket
+ * description:  map is to socket
+ * in param:     struct socket *socket, id_event_t *id
+ * out param:    n/a
+ * return:       VSENTRY_ERROR/VSENTRY_SUCCESS
+ **********************************************************************/
+static int map_process_to_socket(struct socket *socket, id_event_t *id)
+{
+	struct s2p_node_t *s2p_node = NULL;
+	unsigned char hash = hash_ptr(socket, NUM_OF_BUCKETS_BITS);
+	struct hlist_head *head = &socket_process_map[hash];
+	unsigned long flag;
+
+	s2p_node = kzalloc(sizeof(struct s2p_node_t), GFP_KERNEL);
+	if (!s2p_node) {
+		vs_hook_err("failed to allocate s2p_node\n");
+		return VSENTRY_ERROR;
+	}
+
+	INIT_HLIST_NODE(&s2p_node->list);
+	memcpy(&s2p_node->s2p.id, id, sizeof(id_event_t));
+	s2p_node->s2p.inode = SOCK_INODE(socket);
+	s2p_node->s2p.socket = socket;
+	s2p_node->s2p.pid = current->pid;
+
+	spin_lock_irqsave(&socket_process_map_lock, flag);
+
+	rcu_read_lock();
+
+	hlist_add_head_rcu(&s2p_node->list, head);
+
+	rcu_read_unlock();
+
+	spin_unlock_irqrestore(&socket_process_map_lock, flag);
+
+	vs_hook_dbg("mapped socket 0x%px to exec_ino %lu uid %u pid %u\n",
+			socket, id->exec_ino, id->uid, s2p_node->s2p.pid);
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:     get_id_by_socket
+ * description:  search is by socket
+ * in param:     struct socket *socket
+ * out param:    id_event_t *id
+ * return:       VSENTRY_ERROR/VSENTRY_SUCCESS
+ **********************************************************************/
+static int get_id_by_socket(struct socket *socket, id_event_t *id)
+{
+	struct s2p_node_t *s2p_node = NULL;
+	unsigned char hash = hash_ptr(socket, NUM_OF_BUCKETS_BITS);
+	struct hlist_head *head = &socket_process_map[hash];
+	int ret = VSENTRY_ERROR;
+
+	rcu_read_lock();
+
+	hlist_for_each_entry_rcu(s2p_node, head, list) {
+		if (s2p_node->s2p.socket == socket) {
+			vs_hook_dbg("found socket 0x%px exec_ino %lu uid %u\n",
+				s2p_node->s2p.socket, s2p_node->s2p.id.exec_ino,
+				s2p_node->s2p.id.uid);
+			memcpy(id, &s2p_node->s2p.id, sizeof(id_event_t));
+			if (s2p_node->s2p.pid) {
+				if (vsentry_get_file_cls_mode() == FILE_CLS_MODE_STR)
+					vsentry_get_pid_exec_path(s2p_node->s2p.pid, id);
+			}
+			ret = VSENTRY_SUCCESS;
+			break;
+		}
+	}
+
+	rcu_read_unlock();
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     socket_by_inode_delete
+ * description:  rcu complete callback function to free s2p_node
+ * in param:     struct rcu_head *rhead
+ * out param:    n/a
+ * return:       n/a
+ **********************************************************************/
+static void socket_by_inode_delete(struct rcu_head *rhead)
+{
+	struct s2p_node_t *s2p_node = container_of(rhead, struct s2p_node_t, rhead);
+
+	vs_hook_dbg("deleting socket 0x%px to exec_ino %lu uid %u pid %u\n",
+			s2p_node->s2p.socket, s2p_node->s2p.id.exec_ino,
+			s2p_node->s2p.id.uid, s2p_node->s2p.pid);
+
+	kfree(s2p_node);
+}
+
+/***********************************************************************
+ * function:     unmap_socket_by_inode
+ * description:  delete s2p mapping by inode.
+ * in param:     struct inode *inode
+ * out param:    n/a
+ * return:       VSENTRY_ERROR/VSENTRY_SUCCESS
+ **********************************************************************/
+static void unmap_socket_by_inode(struct inode *inode)
+{
+	struct s2p_node_t *s2p_node = NULL;
+	struct socket *socket = SOCKET_I(inode);
+	unsigned char hash = hash_ptr(socket, NUM_OF_BUCKETS_BITS);
+	struct hlist_head *head = &socket_process_map[hash];
+	unsigned long flag;
+
+	spin_lock_irqsave(&socket_process_map_lock, flag);
+
+	rcu_read_lock();
+
+	hlist_for_each_entry(s2p_node, head, list) {
+		if (s2p_node->s2p.socket == socket) {
+			vs_hook_dbg("unmapped socket 0x%px to exec_ino %lu uid %u pid %u\n",
+				s2p_node->s2p.socket, s2p_node->s2p.id.exec_ino,
+				s2p_node->s2p.id.uid, s2p_node->s2p.pid);
+			hlist_del_rcu(&s2p_node->list);
+			call_rcu(&s2p_node->rhead, socket_by_inode_delete);
+		}
+	}
+
+	rcu_read_unlock();
+
+	spin_unlock_irqrestore(&socket_process_map_lock, flag);
+}
+
+#if 0
+static int vsentry_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static int vsentry_binder_transaction(struct task_struct *from,
+	struct task_struct *to)
+{
+	return 0;
+}
+
+static int vsentry_binder_transfer_binder(struct task_struct *from,
+	struct task_struct *to)
+{
+	return 0;
+}
+
+static int vsentry_binder_transfer_file(struct task_struct *from,
+	struct task_struct *to, struct file *file)
+{
+	return 0;
+}
+
+static int vsentry_ptrace_access_check(struct task_struct *child,
+				unsigned int mode)
+{
+	return 0;
+}
+
+static int vsentry_ptrace_traceme(struct task_struct *parent)
+{
+	return 0;
+}
+
+static int vsentry_capget(struct task_struct *target, kernel_cap_t *effective,
+	kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	return 0;
+}
+
+static int vsentry_capset(struct cred *new, const struct cred *old,
+	const kernel_cap_t *effective, const kernel_cap_t *inheritable,
+	const kernel_cap_t *permitted)
+{
+	return 0;
+}
+
+static int vsentry_capable(const struct cred *cred, struct user_namespace *ns,
+		int cap, int audit)
+{
+	return 0;
+}
+
+static int vsentry_quotactl(int cmds, int type, int id, struct super_block *sb)
+{
+	return 0;
+}
+
+static int vsentry_quota_on(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_syslog(int type)
+{
+	return 0;
+}
+
+static int vsentry_settime(const struct timespec64 *ts,
+	const struct timezone *tz)
+{
+	return 0;
+}
+
+static int vsentry_vm_enough_memory(struct mm_struct *mm, long pages)
+{
+	return 0;
+}
+
+static int vsentry_bprm_set_creds(struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:     vsentry_bprm_check_security
+ * description:  this function checks if current process can execute
+ *               the file specified in bprm->file.
+ * in param:     struct linux_binprm *bprm
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_bprm_check_security(struct linux_binprm *bprm)
+{
+	vs_hook_dbg("\n");
+	return vsentry_handle_file_event(&bprm->file->f_path, FILE_MODE_EXEC);
+}
+
+#if 0
+
+static void vsentry_bprm_committing_creds(struct linux_binprm *bprm)
+{
+}
+
+static void vsentry_bprm_committed_creds(struct linux_binprm *bprm)
+{
+}
+
+static int vsentry_sb_alloc_security(struct super_block *sb)
+{
+	return 0;
+}
+
+static void vsentry_sb_free_security(struct super_block *sb)
+{
+}
+
+static int vsentry_sb_copy_data(char *orig, char *copy)
+{
+	return 0;
+}
+
+static int vsentry_sb_remount(struct super_block *sb, void *data)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:     vsentry_sb_kern_mount
+ * description:  register the mount file type. this function helps us
+ *               to fast convert s_magic to vsentry file type.
+ * in param:     struct super_block *sb
+ *               int flags
+ *               void *data
+ * out param:    n/a
+ * return:       0
+ **********************************************************************/
+static int vsentry_sb_kern_mount(struct super_block *sb, int flags, void *data)
+{
+	struct sb_to_vsentry_t *s2v;
+	unsigned char hash = hash_32(sb->s_magic, NUM_OF_BUCKETS_BITS);
+
+	s2v = kzalloc(sizeof(struct sb_to_vsentry_t), GFP_KERNEL);
+	if (!s2v) {
+		vs_hook_err("failed to allocate s2v\n");
+		return 0;
+	}
+
+	s2v->s_magic = sb->s_magic;
+	switch(sb->s_magic) {
+	case XENFS_SUPER_MAGIC:
+	case PROC_SUPER_MAGIC:
+		s2v->vsentry_type = FILE_TYPE_PROCFS;
+		break;
+	case DEBUGFS_MAGIC:
+	case SECURITYFS_MAGIC:
+	case SELINUX_MAGIC:
+	case SMACK_MAGIC:
+	case CGROUP_SUPER_MAGIC:
+	case CGROUP2_SUPER_MAGIC:
+	case TRACEFS_MAGIC:
+	case SYSFS_MAGIC:
+	case FUTEXFS_SUPER_MAGIC:
+	case SOCKFS_MAGIC:
+	case PIPEFS_MAGIC:
+		s2v->vsentry_type = FILE_TYPE_SYSFS;
+		break;
+	default:
+		s2v->vsentry_type = FILE_TYPE_REG;
+		break;
+	}
+
+	spin_lock(&super_block_map_lock);
+
+	hlist_add_head(&s2v->node, &super_block_map[hash]);
+
+	spin_unlock(&super_block_map_lock);
+
+	vs_hook_dbg("mapped sb 0x%lx to %u\n", sb->s_magic, s2v->vsentry_type);
+
+	return 0;
+}
+
+#if 0
+
+static int vsentry_sb_show_options(struct seq_file *m, struct super_block *sb)
+{
+	return 0;
+}
+
+static int vsentry_sb_statfs(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_sb_mount(const char *dev_name, const struct path *path,
+	const char *type, unsigned long flags, void *data)
+{
+	return 0;
+}
+
+static int vsentry_sb_umount(struct vfsmount *mnt, int flags)
+{
+	return 0;
+}
+
+static int vsentry_sb_pivotroot(const struct path *old_path,
+	const struct path *new_path)
+{
+	return 0;
+}
+
+static int vsentry_sb_set_mnt_opts(struct super_block *sb,
+	struct security_mnt_opts *opts, unsigned long kern_flags,
+	unsigned long *set_kern_flags)
+{
+	return 0;
+}
+
+static int vsentry_sb_clone_mnt_opts(const struct super_block *oldsb,
+	struct super_block *newsb, unsigned long kern_flags,
+	unsigned long *set_kern_flags)
+{
+	return 0;
+}
+
+static int vsentry_sb_parse_opts_str(char *options,
+	struct security_mnt_opts *opts)
+{
+	return 0;
+}
+
+static int vsentry_dentry_init_security(struct dentry *dentry, int mode,
+	const struct qstr *name, void **ctx, u32 *ctxlen)
+{
+	return 0;
+}
+
+static int vsentry_dentry_create_files_as(struct dentry *dentry, int mode,
+	struct qstr *name, const struct cred *old, struct cred *new)
+{
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_SECURITY_PATH
+
+/***********************************************************************
+ * function:     vsentry_path_unlink
+ * description:  check if current process can delete a dentry from dir.
+ * in param:     const struct path *dir - path struct of parent
+ *                                        directory of the file.
+ *               struct dentry *dentry - the dentry structure for file
+ *                                       to be unlinked.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_unlink(const struct path *dir, struct dentry *dentry)
+{
+	int ret;
+
+	vs_hook_dbg("\n");
+
+	ret  = vsentry_handle_file_event(dir, FILE_MODE_WRITE);
+	if (!ret)
+		vsentry_cls_remove_inode(dentry->d_inode->i_ino);
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     vsentry_path_mkdir
+ * description:  check if current process can create a new directory.
+ * in param:     const struct path *dir - path structure of parent of
+ *                                        the directory to be created.
+ *               struct dentry *dentry - dentry structure of new
+ *                                       directory.
+ *               umode_t mode - mode of new directory.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_mkdir(const struct path *dir, struct dentry *dentry,
+			umode_t mode)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(dir, FILE_MODE_WRITE);
+}
+
+/***********************************************************************
+ * function:     vsentry_path_rmdir
+ * description:  check if current process can delete a directory.
+ * in param:     const struct path *dir - path structure of parent of
+ *                                        the directory to be removed.
+ *               struct dentry *dentry - dentry structure of directory
+ *                                       to be removed.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_rmdir(const struct path *dir, struct dentry *dentry)
+{
+	int ret;
+
+	vs_hook_dbg("\n");
+
+	ret = vsentry_handle_file_event(dir, FILE_MODE_WRITE);
+	if (!ret)
+		vsentry_cls_remove_inode(dentry->d_inode->i_ino);
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     vsentry_path_mknod
+ * description:  check if current process can create a file.
+ * in param:     const struct path *dir - path structure of parent of
+ *                                        the new file.
+ *               struct dentry *dentry - dentry structure of the new
+ *                                       file.
+ *               umode_t mode - mode of the new file.
+ *               unsigned int dev - undecoded device number.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_mknod(const struct path *dir, struct dentry *dentry,
+	umode_t mode, unsigned int dev)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(dir, FILE_MODE_WRITE);
+}
+
+#if 0
+static int vsentry_path_truncate(const struct path *path)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:     vsentry_path_symlink
+ * description:  check if current process can create a  a symbolic link
+ *               to a file.
+ * in param:     const struct path *dir - path structure of parent
+ *                                        directory of the symbolic link.
+ *               struct dentry *dentry - dentry structure of the
+ *                                       symbolic link.
+ *               const char *old_name - the pathname of file.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_symlink(const struct path *dir, struct dentry *dentry,
+	const char *old_name)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(dir, FILE_MODE_WRITE);
+}
+
+/***********************************************************************
+ * function:     vsentry_path_link
+ * description:  check if current process can create a link in directory
+ * in param:     struct dentry *old_dentry - dentry structure for an
+ *                                           existing link to the file.
+ *               const struct path *new_dir - path structure of the
+ *                                            parent directory of
+ *                                            the new link.
+ *	         struct dentry *new_dentry - dentry structure for the
+ *	                                     new link.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_link(struct dentry *old_dentry,
+	const struct path *new_dir, struct dentry *new_dentry)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(new_dir, FILE_MODE_WRITE);
+}
+
+/***********************************************************************
+ * function:     vsentry_path_rename
+ * description:  check if current process can delete the old_dentry
+ *               from old_dir, and can create new_dentry in new_dir.
+ * in param:     const struct path *old_dir - path structure for parent
+ *                                            of the old link.
+ *               struct dentry *old_dentry - dentry structure of the old
+ *                                           link
+ *               const struct path *new_dir - path structure for parent
+ *                                            of the new link.
+ *               struct dentry *new_dentry - dentry structure of the
+ *                                           new link.
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_rename(const struct path *old_dir,
+	struct dentry *old_dentry, const struct path *new_dir,
+	struct dentry *new_dentry)
+{
+	int ret;
+	vs_hook_dbg("\n");
+
+	if (vsentry_handle_file_event(old_dir, FILE_MODE_WRITE) != 0)
+		return -EACCES;
+
+	ret = vsentry_handle_file_event(new_dir, FILE_MODE_WRITE);
+	if(!ret)
+		vsentry_cls_remove_inode(old_dentry->d_inode->i_ino);
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:     vsentry_path_chmod
+ * description:  check if current process can change file mode.
+ * in param:     const struct path *path
+ *               umode_t mode
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_chmod(const struct path *path, umode_t mode)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(path, FILE_MODE_WRITE);
+}
+
+/***********************************************************************
+ * function:     vsentry_path_chown
+ * description:  check if current process can change a file owner.
+ * in param:     const struct path *path
+ *               kuid_t uid
+ *               kgid_t gid
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_path_chown(const struct path *path, kuid_t uid, kgid_t gid)
+{
+	vs_hook_dbg("\n");
+
+	return vsentry_handle_file_event(path, FILE_MODE_WRITE);
+}
+
+#if 0
+
+static int vsentry_path_chroot(const struct path *path)
+{
+	return 0;
+}
+#endif
+
+#endif /* CONFIG_SECURITY_PATH */
+
+#if 0
+
+static int vsentry_inode_alloc_security(struct inode *inode)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:     vsentry_inode_free_security
+ * description:  the hook is used to remove a socket from the socket to
+ *               exec_inode mapping.
+ * in param:     struct inode *inode
+ * out param:    n/a
+ * return:       n/a
+ **********************************************************************/
+static void vsentry_inode_free_security(struct inode *inode)
+{
+	if (!S_ISSOCK(inode->i_mode))
+		return;
+
+	unmap_socket_by_inode(inode);
+}
+
+#if 0
+
+static int vsentry_inode_init_security(struct inode *inode, struct inode *dir,
+	const struct qstr *qstr, const char **name, void **value, size_t *len)
+{
+	return 0;
+}
+
+static int vsentry_inode_create(struct inode *dir, struct dentry *dentry,
+	umode_t mode)
+{
+	return 0;
+}
+
+
+
+static int vsentry_inode_link(struct dentry *old_dentry, struct inode *dir,
+	struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_unlink(struct inode *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_symlink(struct inode *dir, struct dentry *dentry,
+	const char *old_name)
+{
+	return 0;
+}
+
+static int vsentry_inode_mkdir(struct inode *dir, struct dentry *dentry,
+	umode_t mode)
+{
+	return 0;
+}
+
+static int vsentry_inode_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_mknod(struct inode *dir, struct dentry *dentry,
+	umode_t mode, dev_t dev)
+{
+	return 0;
+}
+
+static int vsentry_inode_rename(struct inode *old_dir,
+	struct dentry *old_dentry, struct inode *new_dir,
+	struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_readlink(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_follow_link(struct dentry *dentry,
+	struct inode *inode, bool rcu)
+{
+	return 0;
+}
+
+static int vsentry_inode_permission(struct inode *inode, int mask)
+{
+	return 0;
+}
+
+static int vsentry_inode_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	return 0;
+}
+
+static int vsentry_inode_getattr(const struct path *path)
+{
+	return 0;
+}
+
+static int vsentry_inode_setxattr(struct dentry *dentry, const char *name,
+			const void *value, size_t size, int flags)
+{
+	return 0;
+}
+
+static void vsentry_inode_post_setxattr(struct dentry *dentry,
+	const char *name, const void *value, size_t size, int flags)
+{
+}
+
+static int vsentry_inode_getxattr(struct dentry *dentry, const char *name)
+{
+	return 0;
+}
+
+static int vsentry_inode_listxattr(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_removexattr(struct dentry *dentry, const char *name)
+{
+	return 0;
+}
+
+static int vsentry_inode_need_killpriv(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_killpriv(struct dentry *dentry)
+{
+	return 0;
+}
+
+static int vsentry_inode_getsecurity(struct inode *inode, const char *name,
+				void **buffer, bool alloc)
+{
+	return 0;
+}
+
+static int vsentry_inode_setsecurity(struct inode *inode, const char *name,
+				const void *value, size_t size,
+				int flags)
+{
+	return 0;
+}
+
+static int vsentry_inode_listsecurity(struct inode *inode, char *buffer,
+				size_t buffer_size)
+{
+	return 0;
+}
+
+static void vsentry_inode_getsecid(struct inode *inode, u32 *secid)
+{
+	return 0;
+}
+
+static int vsentry_inode_copy_up(struct dentry *src, struct cred **new)
+{
+	return 0;
+}
+
+static int vsentry_inode_copy_up_xattr(const char *name)
+{
+	return 0;
+}
+
+static int vsentry_file_permission(struct file *file, int mask)
+{
+	return 0;
+}
+
+static int vsentry_file_alloc_security(struct file *file)
+{
+	return 0;
+}
+
+static void vsentry_file_free_security(struct file *file)
+{
+}
+
+static int vsentry_file_ioctl(struct file *file, unsigned int cmd,
+			unsigned long arg)
+{
+	return 0;
+}
+
+static int vsentry_mmap_addr(unsigned long addr)
+{
+	return 0;
+}
+
+static int vsentry_mmap_file(struct file *file, unsigned long reqprot,
+			unsigned long prot, unsigned long flags)
+{
+	return 0;
+}
+
+static int vsentry_file_mprotect(struct vm_area_struct *vma,
+	unsigned long reqprot, unsigned long prot)
+{
+	return 0;
+}
+
+static int vsentry_file_lock(struct file *file, unsigned int cmd)
+{
+	return 0;
+}
+
+static int vsentry_file_fcntl(struct file *file, unsigned int cmd,
+			unsigned long arg)
+{
+	return 0;
+}
+
+static void vsentry_file_set_fowner(struct file *file)
+{
+}
+
+static int vsentry_file_send_sigiotask(struct task_struct *tsk,
+				struct fown_struct *fown, int sig)
+{
+	return 0;
+}
+
+static int vsentry_file_receive(struct file *file)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:     vsentry_file_open
+ * description:  check if current process can read the file
+ * in param:     struct file *file
+ *               const struct cred *cred
+ * out param:    n/a
+ * return:       0/-EACCES
+ **********************************************************************/
+static int vsentry_file_open(struct file *file, const struct cred *cred)
+{
+	unsigned int mode = 0;
+
+	vs_hook_dbg("\n");
+
+	if (file->f_mode & FMODE_READ)
+		mode |= FILE_MODE_READ;
+	if (file->f_mode & FMODE_WRITE)
+		mode |= FILE_MODE_WRITE;
+	if (file->f_mode & FMODE_EXEC)
+		mode |= FILE_MODE_EXEC;
+
+	return vsentry_handle_file_event(&file->f_path, mode);
+}
+
+#if 0
+
+static int vsentry_task_create(unsigned long clone_flags)
+{
+	return 0;
+}
+
+static void vsentry_task_free(struct task_struct *task)
+{
+}
+
+static int vsentry_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+	return 0;
+}
+
+static void vsentry_cred_free(struct cred *cred)
+{
+}
+
+static int vsentry_cred_prepare(struct cred *new, const struct cred *old,
+			gfp_t gfp)
+{
+	return 0;
+}
+
+static void vsentry_cred_transfer(struct cred *new, const struct cred *old)
+{
+}
+
+static int vsentry_kernel_act_as(struct cred *new, u32 secid)
+{
+	return 0;
+}
+
+static int vsentry_kernel_create_files_as(struct cred *new,
+	struct inode *inode)
+{
+	return 0;
+}
+
+static int vsentry_kernel_module_request(char *kmod_name)
+{
+	return 0;
+}
+
+static int vsentry_kernel_read_file(struct file *file,
+	enum kernel_read_file_id id)
+{
+	return 0;
+}
+
+static int vsentry_kernel_post_read_file(struct file *file, char *buf,
+	loff_t size, enum kernel_read_file_id id)
+{
+	return 0;
+}
+
+static int vsentry_task_fix_setuid(struct cred *new, const struct cred *old,
+			int flags)
+{
+	return 0;
+}
+
+static int vsentry_task_setpgid(struct task_struct *p, pid_t pgid)
+{
+	return 0;
+}
+
+static int vsentry_task_getpgid(struct task_struct *p)
+{
+	return 0;
+}
+
+static int vsentry_task_getsid(struct task_struct *p)
+{
+	return 0;
+}
+
+static void vsentry_task_getsecid(struct task_struct *p, u32 *secid)
+{
+}
+
+static int vsentry_task_setnice(struct task_struct *p, int nice)
+{
+	return 0;
+}
+
+static int vsentry_task_setioprio(struct task_struct *p, int ioprio)
+{
+	return 0;
+}
+
+static int vsentry_task_getioprio(struct task_struct *p)
+{
+	return 0;
+}
+
+static int vsentry_task_setrlimit(struct task_struct *p,
+	unsigned int resource, struct rlimit *new_rlim)
+{
+	return 0;
+}
+
+static int vsentry_task_setscheduler(struct task_struct *p)
+{
+	return 0;
+}
+
+static int vsentry_task_getscheduler(struct task_struct *p)
+{
+	return 0;
+}
+
+static int vsentry_task_movememory(struct task_struct *p)
+{
+	return 0;
+}
+
+static int vsentry_task_kill(struct task_struct *p, struct siginfo *info,
+	int sig, u32 secid)
+{
+	return 0;
+}
+
+static int vsentry_task_prctl(int option, unsigned long arg2,
+	unsigned long arg3, unsigned long arg4, unsigned long arg5)
+{
+	return 0;
+}
+
+static void vsentry_task_to_inode(struct task_struct *p, struct inode *inode)
+{
+	struct vs_hook_t *hook = &vsentry_lsm_hooks[VSENTRY_LHT_TASK_TO_INODE];
+
+	call_lsm_hook(hook, p, inode);
+}
+
+
+static int vsentry_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
+{
+	return 0;
+}
+
+static void vsentry_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
+{
+}
+
+static int vsentry_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	return 0;
+}
+
+static void vsentry_msg_msg_free_security(struct msg_msg *msg)
+{
+}
+
+static int vsentry_msg_queue_alloc_security(struct msg_queue *msq)
+{
+	return 0;
+}
+
+static void vsentry_msg_queue_free_security(struct msg_queue *msq)
+{
+}
+
+static int vsentry_msg_queue_associate(struct msg_queue *msq, int msqflg)
+{
+	return 0;
+}
+
+static int vsentry_msg_queue_msgctl(struct msg_queue *msq, int cmd)
+{
+	return 0;
+}
+
+static int vsentry_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,
+			int msqflg)
+{
+	return 0;
+}
+
+static int vsentry_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+			struct task_struct *target, long type,
+			int mode)
+{
+	return 0;
+}
+
+static int vsentry_shm_alloc_security(struct shmid_kernel *shp)
+{
+	return 0;
+}
+
+static void vsentry_shm_free_security(struct shmid_kernel *shp)
+{
+}
+
+static int vsentry_shm_associate(struct shmid_kernel *shp, int shmflg)
+{
+	return 0;
+}
+
+static int vsentry_shm_shmctl(struct shmid_kernel *shp, int cmd)
+{
+	return 0;
+}
+
+static int vsentry_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,
+			int shmflg)
+{
+	return 0;
+}
+
+static int vsentry_sem_alloc_security(struct sem_array *sma)
+{
+	return 0;
+}
+
+static void vsentry_sem_free_security(struct sem_array *sma)
+{
+}
+
+static int vsentry_sem_associate(struct sem_array *sma, int semflg)
+{
+	return 0;
+}
+
+static int vsentry_sem_semctl(struct sem_array *sma, int cmd)
+{
+	return 0;
+}
+
+static int vsentry_sem_semop(struct sem_array *sma, struct sembuf *sops,
+	unsigned nsops, int alter)
+{
+	return 0;
+}
+
+static int vsentry_netlink_send(struct sock *sk, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static void vsentry_d_instantiate(struct dentry *dentry, struct inode *inode)
+{
+}
+
+static int vsentry_getprocattr(struct task_struct *p, char *name, char **value)
+{
+	return 0;
+}
+
+static int vsentry_setprocattr(const char *name, void *value, size_t size)
+{
+	return 0;
+}
+
+static int vsentry_ismaclabel(const char *name)
+{
+	return 0;
+}
+
+static int vsentry_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
+{
+	return 0;
+}
+
+static int vsentry_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
+{
+	return 0;
+}
+
+static void vsentry_release_secctx(char *secdata, u32 seclen)
+{
+}
+
+static void vsentry_inode_invalidate_secctx(struct inode *inode)
+{
+}
+
+static int vsentry_inode_notifysecctx(struct inode *inode, void *ctx,
+	u32 ctxlen)
+{
+	return 0;
+}
+
+static int vsentry_inode_setsecctx(struct dentry *dentry, void *ctx,
+	u32 ctxlen)
+{
+	return 0;
+}
+
+static int vsentry_inode_getsecctx(struct inode *inode, void **ctx,
+	u32 *ctxlen)
+{
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_SECURITY_NETWORK
+
+#if 0
+
+static int vsentry_unix_stream_connect(struct sock *sock, struct sock *other,
+				struct sock *newsk)
+{
+	return 0;
+}
+
+static int vsentry_unix_may_send(struct socket *sock, struct socket *other)
+{
+	return 0;
+}
+
+static int vsentry_socket_create(int family, int type, int protocol, int kern)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:    vsentry_socket_post_create
+ * description: we use this hook to register the new socket and assigned it
+ *              with the calling executable/user.
+ * in param:    struct socket *sock
+ *              int family
+ *              int type
+ *              int protocol
+ *              int kern
+ * out param:   n/a
+ * return:      0
+ **********************************************************************/
+static int vsentry_socket_post_create(struct socket *sock, int family,
+	int type, int protocol, int kern)
+{
+	id_event_t id;
+
+	if (family != AF_INET && family != AF_CAN)
+		return 0;
+
+	vs_hook_dbg("%s socket created 0x%px\n",
+		(family == AF_INET)?"net":"can", sock);
+
+	memset(&id, 0, sizeof(id_event_t));
+
+	vsentry_get_current_info(&id);
+
+	map_process_to_socket(sock, &id);
+
+	return 0;
+}
+
+#if 0
+
+static int vsentry_socket_bind(struct socket *sock, struct sockaddr *address,
+			int addrlen)
+{
+	return 0;
+}
+
+static int vsentry_socket_connect(struct socket *sock,
+	struct sockaddr *address, int addrlen)
+{
+	return 0;
+}
+
+static int vsentry_socket_listen(struct socket *sock, int backlog)
+{
+	return 0;
+}
+#endif
+
+/***********************************************************************
+ * function:    vsentry_socket_accept
+ * description: we use this hook to register the new socket and assigned it
+ *              with the calling executable/user. not sure if it is relevant
+ *              to CAN.
+ * in param:    struct socket *sock
+ *              struct socket *newsock
+ * out param:   n/a
+ * return:      0
+ **********************************************************************/
+static int vsentry_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	id_event_t id;
+
+	if (sock->sk->sk_family != AF_INET && sock->sk->sk_family != AF_CAN)
+		return 0;
+
+	vs_hook_dbg("%s socket created 0x%px\n",
+		(sock->sk->sk_family == AF_INET)?"net":"can", sock);
+
+	memset(&id, 0, sizeof(id_event_t));
+
+	vsentry_get_current_info(&id);
+
+	map_process_to_socket(newsock, &id);
+
+	return 0;
+}
+
+/***********************************************************************
+ * function:     vsentry_socket_sendmsg
+ * description:  we use this hook to classify all outgoing CAN traffic.
+ *               IP traffic will be classify by netfilter hook.
+ * in param:     struct socket *sock
+ *               struct msghdr *msg_hdr,
+ *		int size
+ * out param:    n/a
+ * return:       0/-EACCES
+ ***********************************************************************/
+static int vsentry_socket_sendmsg(struct socket *sock, struct msghdr *msg_hdr,
+	int size)
+{
+	vsentry_event_t ev;
+	struct sock *sk = sock->sk;
+	int ret = -EACCES;
+	struct sk_buff *skb;
+	struct sockaddr_can addr;
+	int addrlen, err;
+	u32 if_index = 0;
+	struct msghdr msg_tmp;
+
+	if (!vsentry_get_enable() || sk->sk_family != AF_CAN)
+		return 0;
+
+	memset(&ev, 0, sizeof(vsentry_event_t));
+
+	if (sock->ops->getname(sock,
+			(struct sockaddr *)&addr, &addrlen, 0) == 0)
+		if_index = addr.can_ifindex;
+
+	skb = alloc_skb(sizeof(struct can_skb_priv) +
+		sizeof(struct can_frame), GFP_KERNEL);
+	if (!skb) {
+		pr_err("failed to alloc can skb\n");
+		return -EACCES;
+	}
+
+	msg_tmp = *msg_hdr;
+	can_skb_reserve(skb);
+	err = memcpy_from_msg(skb_put(skb, size), &msg_tmp, size);
+	if (err >= 0) {
+		struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+
+		memset(&ev, 0, sizeof(vsentry_event_t));
+
+		vsentry_get_current_info(&ev.event_id);
+
+		if (vsentry_get_file_cls_mode() == FILE_CLS_MODE_STR)
+			vsentry_get_pid_exec_path(current->pid, &ev.event_id);
+
+		ev.ts = vsentry_get_curr_time_usec();
+		ev.can_event.can_header.msg_id = (CAN_EFF_MASK & cfd->can_id);
+		ev.can_event.can_header.if_index = if_index;
+		ev.dir = DIR_OUT;
+		ev.can_event.payload_len = cfd->len;
+		memcpy(&ev.can_event.payload, cfd->data, cfd->len);
+
+		if (vsentry_check_event(VSENTRY_CAN_EVENT, &ev, false) == VSENTRY_SUCCESS)
+			ret = 0;
+	}
+
+	kfree_skb(skb);
+
+	return ret;
+}
+
+#if 0
+
+static int vsentry_socket_recvmsg(struct socket *sock, struct msghdr *msg_hdr,
+			int size, int flags)
+{
+	return 0;
+}
+
+static int vsentry_socket_getsockname(struct socket *sock)
+{
+	return 0;
+}
+
+static int vsentry_socket_getpeername(struct socket *sock)
+{
+	return 0;
+}
+
+static int vsentry_socket_getsockopt(struct socket *sock, int level,
+	int optname)
+{
+	return 0;
+}
+
+static int vsentry_socket_setsockopt(struct socket *sock, int level,
+	int optname)
+{
+	return 0;
+}
+
+static int vsentry_socket_shutdown(struct socket *sock, int how)
+{
+	return 0;
+}
+
+#endif
+
+/***********************************************************************
+ * function:    vsentry_socket_sock_rcv_skb
+ * description: we use this hook to classify all incomming CAN/IP(TCP/UDP)
+ *              traffic. for IP we use this hook and not the netfilter since
+ *              for incomming traffic, this is the first place in the kernel
+ *              where the buffer is assigned with the socket.
+ * in param:    struct sock *sk - the sock will allow us to find the exec_inode
+ *              struct sk_buff *skb - the buffer
+ * out param:   n/a
+ * return:      0/-EACCES
+ ***********************************************************************/
+static int vsentry_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	int ret = 0;
+	vsentry_event_t ev;
+
+	if (!vsentry_get_enable())
+		return 0;
+
+	memset(&ev, 0, sizeof(vsentry_event_t));
+
+	ev.event_id.exec_name = NULL;
+	ev.ts = vsentry_get_curr_time_usec();
+	ev.dir = DIR_IN;
+
+	/* try to extract the receiver executable/user */
+	if (sk->sk_socket)
+		get_id_by_socket(sk->sk_socket, &ev.event_id);
+	else
+		ev.event_id.kernel = true;
+
+	switch (sk->sk_family) {
+	case AF_CAN:
+	{
+		struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+		struct socket *sock = sk->sk_socket;
+		struct sockaddr_can addr;
+		int addrlen;
+
+		vs_hook_dbg("classify rx can\n");
+
+		/* extract CAN evetn data */
+		if (sock->ops->getname(sock,
+				(struct sockaddr *)&addr, &addrlen, 0) == 0)
+			ev.can_event.can_header.if_index = addr.can_ifindex;
+		ev.can_event.can_header.msg_id = CAN_EFF_MASK & cfd->can_id;
+		ev.can_event.payload_len = cfd->len;
+		memcpy(&ev.can_event.payload, cfd->data, cfd->len);
+
+		if (vsentry_check_event(VSENTRY_CAN_EVENT, &ev, true) != VSENTRY_SUCCESS)
+			ret = -EACCES;
+
+		break;
+	}
+
+	case AF_INET:
+	{
+		struct iphdr *ip_header =
+			(struct iphdr *)skb_network_header(skb);
+
+		/* classify only TCP/UDP */
+		if (ip_header->protocol != IPPROTO_TCP &&
+				ip_header->protocol != IPPROTO_UDP)
+			return 0;
+
+		vs_hook_dbg("classify rx net\n");
+
+		ev.ip_event.ip_proto = ip_header->protocol;
+		vsentry_extract_ip_info(&ev.ip_event, skb);
+
+		if (vsentry_check_event(VSENTRY_IP_EVENT, &ev, true) != VSENTRY_SUCCESS)
+			ret = -EACCES;
+		break;
+	}
+
+	default:
+		ret = 0;
+		break;
+	}
+
+	if (ev.event_id.exec_name)
+		free_name(ev.event_id.exec_name);
+
+	return ret;
+}
+
+#if 0
+
+static int vsentry_socket_getpeersec_stream(struct socket *sock,
+				char __user *optval,
+				int __user *optlen, unsigned len)
+{
+	return 0;
+}
+
+static int vsentry_socket_getpeersec_dgram(struct socket *sock,
+				struct sk_buff *skb, u32 *secid)
+{
+	return 0;
+}
+
+static int vsentry_sk_alloc_security(struct sock *sk, int family,
+	gfp_t priority)
+{
+	return 0;
+}
+
+static void vsentry_sk_free_security(struct sock *sk)
+{
+}
+
+static void vsentry_sk_clone_security(const struct sock *sk,
+	struct sock *newsk)
+{
+}
+
+static void vsentry_sk_getsecid(struct sock *sk, u32 *secid)
+{
+}
+
+static void vsentry_sock_graft(struct sock *sk, struct socket *parent)
+{
+}
+
+static int vsentry_inet_conn_request(struct sock *sk, struct sk_buff *skb,
+				struct request_sock *req)
+{
+	vsentry_event_t ev;
+	struct iphdr *ip_header = NULL;
+
+	if (!vsentry_get_enable())
+		return 0;
+
+	vs_hook_dbg("classify rx net\n");
+
+	ev.ts = vsentry_get_curr_time_usec();
+	ev.dir = DIR_IN;
+	ev.event_id.exec_name = NULL;
+
+	/* try to extract the receiver executable/user */
+	if (sk->sk_socket)
+		get_id_by_socket(sk->sk_socket, &ev.event_id);
+
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	ev.ip_event.ip_proto = ip_header->protocol;
+	vsentry_extract_ip_info(&ev.ip_event, skb);
+
+	vsentry_check_event(VSENTRY_IP_EVENT, &ev, true);
+
+	if (ev.event_id.exec_name)
+		free_name(ev.event_id.exec_name);
+
+	return 0;
+}
+
+static void vsentry_inet_csk_clone(struct sock *newsk,
+			const struct request_sock *req)
+{
+}
+
+static void vsentry_inet_conn_established(struct sock *sk, struct sk_buff *skb)
+{
+	vsentry_event_t ev;
+	struct iphdr *ip_header = NULL;
+
+	if (!vsentry_get_enable())
+		return;
+
+	vs_hook_dbg("classify rx net\n");
+
+	ev.ts = vsentry_get_curr_time_usec();
+	ev.dir = DIR_IN;
+	ev.event_id.exec_name = NULL;
+
+	/* try to extract the receiver executable/user */
+	if (sk->sk_socket)
+		get_id_by_socket(sk->sk_socket, &ev.event_id);
+
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	ev.ip_event.ip_proto = ip_header->protocol;
+	vsentry_extract_ip_info(&ev.ip_event, skb);
+
+	vsentry_check_event(VSENTRY_IP_EVENT, &ev, true);
+
+	if (ev.event_id.exec_name)
+		free_name(ev.event_id.exec_name);
+}
+
+static int vsentry_secmark_relabel_packet(u32 secid)
+{
+	return 0;
+}
+
+static void vsentry_secmark_refcount_inc(void)
+{
+}
+
+static void vsentry_secmark_refcount_dec(void)
+{
+}
+
+static void vsentry_req_classify_flow(const struct request_sock *req,
+				struct flowi *fl)
+{
+}
+
+static int vsentry_tun_dev_alloc_security(void **security)
+{
+	return 0;
+}
+
+static void vsentry_tun_dev_free_security(void *security)
+{
+}
+
+static int vsentry_tun_dev_create(void)
+{
+	return 0;
+}
+
+static int vsentry_tun_dev_attach_queue(void *security)
+{
+	return 0;
+}
+
+static int vsentry_tun_dev_attach(struct sock *sk, void *security)
+{
+	return 0;
+}
+
+static int vsentry_tun_dev_open(void *security)
+{
+	return 0;
+}
+
+#endif
+
+#endif  /* CONFIG_SECURITY_NETWORK */
+
+#ifdef CONFIG_SECURITY_NETWORK_XFRM
+
+#if 0
+
+static int vsentry_xfrm_policy_alloc_security(struct xfrm_sec_ctx **ctxp,
+	struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_policy_clone_security(struct xfrm_sec_ctx *old_ctx,
+					struct xfrm_sec_ctx **new_ctx)
+{
+	return 0;
+}
+
+static void vsentry_xfrm_policy_free_security(struct xfrm_sec_ctx *ctx)
+{
+}
+
+static int vsentry_xfrm_policy_delete_security(struct xfrm_sec_ctx *ctx)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_state_alloc(struct xfrm_state *x,
+			struct xfrm_user_sec_ctx *sec_ctx)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_state_alloc_acquire(struct xfrm_state *x,
+				struct xfrm_sec_ctx *polsec,
+				u32 secid)
+{
+	return 0;
+}
+
+static void vsentry_xfrm_state_free_security(struct xfrm_state *x)
+{
+}
+
+static int vsentry_xfrm_state_delete_security(struct xfrm_state *x)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid,
+	u8 dir)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_state_pol_flow_match(struct xfrm_state *x,
+					struct xfrm_policy *xp,
+					const struct flowi *fl)
+{
+	return 0;
+}
+
+static int vsentry_xfrm_decode_session(struct sk_buff *skb, u32 *secid,
+	int ckall)
+{
+	return 0;
+}
+
+#endif
+
+#endif /* CONFIG_SECURITY_NETWORK_XFRM */
+
+static struct security_hook_list vsentry_default_lsm_hooks[] = {
+#if 0
+	LSM_HOOK_INIT(binder_set_context_mgr, vsentry_binder_set_context_mgr),
+	LSM_HOOK_INIT(binder_transaction, vsentry_binder_transaction),
+	LSM_HOOK_INIT(binder_transfer_binder, vsentry_binder_transfer_binder),
+	LSM_HOOK_INIT(binder_transfer_file, vsentry_binder_transfer_file),
+	LSM_HOOK_INIT(ptrace_access_check, vsentry_ptrace_access_check),
+	LSM_HOOK_INIT(ptrace_traceme, vsentry_ptrace_traceme),
+	LSM_HOOK_INIT(capget, vsentry_capget),
+	LSM_HOOK_INIT(capset, vsentry_capset),
+	LSM_HOOK_INIT(capable, vsentry_capable),
+	LSM_HOOK_INIT(quotactl, vsentry_quotactl),
+	LSM_HOOK_INIT(quota_on, vsentry_quota_on),
+	LSM_HOOK_INIT(syslog, vsentry_syslog),
+	LSM_HOOK_INIT(settime, vsentry_settime),
+	LSM_HOOK_INIT(vm_enough_memory, vsentry_vm_enough_memory),
+	LSM_HOOK_INIT(bprm_set_creds, vsentry_bprm_set_creds),
+#endif
+	LSM_HOOK_INIT(bprm_check_security, vsentry_bprm_check_security),
+#if 0
+	LSM_HOOK_INIT(bprm_committing_creds, vsentry_bprm_committing_creds),
+	LSM_HOOK_INIT(bprm_committed_creds, vsentry_bprm_committed_creds),
+	LSM_HOOK_INIT(sb_alloc_security, vsentry_sb_alloc_security),
+	LSM_HOOK_INIT(sb_free_security, vsentry_sb_free_security),
+	LSM_HOOK_INIT(sb_copy_data, vsentry_sb_copy_data),
+	LSM_HOOK_INIT(sb_remount, vsentry_sb_remount),
+#endif
+	LSM_HOOK_INIT(sb_kern_mount, vsentry_sb_kern_mount),
+#if 0
+	LSM_HOOK_INIT(sb_show_options, vsentry_sb_show_options),
+	LSM_HOOK_INIT(sb_statfs, vsentry_sb_statfs),
+	LSM_HOOK_INIT(sb_mount, vsentry_sb_mount),
+	LSM_HOOK_INIT(sb_umount, vsentry_sb_umount),
+	LSM_HOOK_INIT(sb_pivotroot, vsentry_sb_pivotroot),
+	LSM_HOOK_INIT(sb_set_mnt_opts, vsentry_sb_set_mnt_opts),
+	LSM_HOOK_INIT(sb_clone_mnt_opts, vsentry_sb_clone_mnt_opts),
+	LSM_HOOK_INIT(sb_parse_opts_str, vsentry_sb_parse_opts_str),
+	LSM_HOOK_INIT(dentry_init_security, vsentry_dentry_init_security),
+	LSM_HOOK_INIT(dentry_create_files_as, vsentry_dentry_create_files_as),
+#endif
+#ifdef CONFIG_SECURITY_PATH
+	LSM_HOOK_INIT(path_unlink, vsentry_path_unlink),
+	LSM_HOOK_INIT(path_mkdir, vsentry_path_mkdir),
+	LSM_HOOK_INIT(path_rmdir, vsentry_path_rmdir),
+	LSM_HOOK_INIT(path_mknod, vsentry_path_mknod),
+#if 0
+	LSM_HOOK_INIT(path_truncate, vsentry_path_truncate),
+#endif
+	LSM_HOOK_INIT(path_symlink, vsentry_path_symlink),
+	LSM_HOOK_INIT(path_link, vsentry_path_link),
+	LSM_HOOK_INIT(path_rename, vsentry_path_rename),
+	LSM_HOOK_INIT(path_chmod, vsentry_path_chmod),
+	LSM_HOOK_INIT(path_chown, vsentry_path_chown),
+#if 0
+	LSM_HOOK_INIT(path_chroot, vsentry_path_chroot),
+#endif
+#endif /* CONFIG_SECURITY_PATH */
+#if 0
+	LSM_HOOK_INIT(inode_alloc_security, vsentry_inode_alloc_security),
+#endif
+	LSM_HOOK_INIT(inode_free_security, vsentry_inode_free_security),
+#if 0
+	LSM_HOOK_INIT(inode_init_security, vsentry_inode_init_security),
+	LSM_HOOK_INIT(inode_create, vsentry_inode_create),
+	LSM_HOOK_INIT(inode_link, vsentry_inode_link),
+	LSM_HOOK_INIT(inode_unlink, vsentry_inode_unlink),
+	LSM_HOOK_INIT(inode_symlink, vsentry_inode_symlink),
+	LSM_HOOK_INIT(inode_mkdir, vsentry_inode_mkdir),
+	LSM_HOOK_INIT(inode_rmdir, vsentry_inode_rmdir),
+	LSM_HOOK_INIT(inode_mknod, vsentry_inode_mknod),
+	LSM_HOOK_INIT(inode_rename, vsentry_inode_rename),
+	LSM_HOOK_INIT(inode_readlink, vsentry_inode_readlink),
+	LSM_HOOK_INIT(inode_follow_link, vsentry_inode_follow_link),
+	LSM_HOOK_INIT(inode_permission, vsentry_inode_permission),
+	LSM_HOOK_INIT(inode_setattr, vsentry_inode_setattr),
+	LSM_HOOK_INIT(inode_getattr, vsentry_inode_getattr),
+	LSM_HOOK_INIT(inode_setxattr, vsentry_inode_setxattr),
+	LSM_HOOK_INIT(inode_post_setxattr, vsentry_inode_post_setxattr),
+	LSM_HOOK_INIT(inode_getxattr, vsentry_inode_getxattr),
+	LSM_HOOK_INIT(inode_listxattr, vsentry_inode_listxattr),
+	LSM_HOOK_INIT(inode_removexattr, vsentry_inode_removexattr),
+	LSM_HOOK_INIT(inode_need_killpriv, vsentry_inode_need_killpriv),
+	LSM_HOOK_INIT(inode_killpriv, vsentry_inode_killpriv),
+	LSM_HOOK_INIT(inode_getsecurity, vsentry_inode_getsecurity),
+	LSM_HOOK_INIT(inode_setsecurity, vsentry_inode_setsecurity),
+	LSM_HOOK_INIT(inode_listsecurity, vsentry_inode_listsecurity),
+	LSM_HOOK_INIT(inode_getsecid, vsentry_inode_getsecid),
+	LSM_HOOK_INIT(inode_copy_up, vsentry_inode_copy_up),
+	LSM_HOOK_INIT(inode_copy_up_xattr, vsentry_inode_copy_up_xattr),
+	LSM_HOOK_INIT(file_permission, vsentry_file_permission),
+	LSM_HOOK_INIT(file_alloc_security, vsentry_file_alloc_security),
+	LSM_HOOK_INIT(file_free_security, vsentry_file_free_security),
+	LSM_HOOK_INIT(file_ioctl, vsentry_file_ioctl),
+	LSM_HOOK_INIT(mmap_addr, vsentry_mmap_addr),
+	LSM_HOOK_INIT(mmap_file, vsentry_mmap_file),
+	LSM_HOOK_INIT(file_mprotect, vsentry_file_mprotect),
+	LSM_HOOK_INIT(file_lock, vsentry_file_lock),
+	LSM_HOOK_INIT(file_fcntl, vsentry_file_fcntl),
+	LSM_HOOK_INIT(file_set_fowner, vsentry_file_set_fowner),
+	LSM_HOOK_INIT(file_send_sigiotask, vsentry_file_send_sigiotask),
+	LSM_HOOK_INIT(file_receive, vsentry_file_receive),
+#endif
+	LSM_HOOK_INIT(file_open, vsentry_file_open),
+#if 0
+	LSM_HOOK_INIT(task_create, vsentry_task_create),
+	LSM_HOOK_INIT(task_free, vsentry_task_free),
+	LSM_HOOK_INIT(cred_alloc_blank, vsentry_cred_alloc_blank),
+	LSM_HOOK_INIT(cred_free, vsentry_cred_free),
+	LSM_HOOK_INIT(cred_prepare, vsentry_cred_prepare),
+	LSM_HOOK_INIT(cred_transfer, vsentry_cred_transfer),
+	LSM_HOOK_INIT(kernel_act_as, vsentry_kernel_act_as),
+	LSM_HOOK_INIT(kernel_create_files_as, vsentry_kernel_create_files_as),
+	LSM_HOOK_INIT(kernel_module_request, vsentry_kernel_module_request),
+	LSM_HOOK_INIT(kernel_read_file, vsentry_kernel_read_file),
+	LSM_HOOK_INIT(kernel_post_read_file, vsentry_kernel_post_read_file),
+	LSM_HOOK_INIT(task_fix_setuid, vsentry_task_fix_setuid),
+	LSM_HOOK_INIT(task_setpgid, vsentry_task_setpgid),
+	LSM_HOOK_INIT(task_getpgid, vsentry_task_getpgid),
+	LSM_HOOK_INIT(task_getsid, vsentry_task_getsid),
+	LSM_HOOK_INIT(task_getsecid, vsentry_task_getsecid),
+	LSM_HOOK_INIT(task_setnice, vsentry_task_setnice),
+	LSM_HOOK_INIT(task_setioprio, vsentry_task_setioprio),
+	LSM_HOOK_INIT(task_getioprio, vsentry_task_getioprio),
+	LSM_HOOK_INIT(task_setrlimit, vsentry_task_setrlimit),
+	LSM_HOOK_INIT(task_setscheduler, vsentry_task_setscheduler),
+	LSM_HOOK_INIT(task_getscheduler, vsentry_task_getscheduler),
+	LSM_HOOK_INIT(task_movememory, vsentry_task_movememory),
+	LSM_HOOK_INIT(task_kill, vsentry_task_kill),
+	LSM_HOOK_INIT(task_prctl, vsentry_task_prctl),
+	LSM_HOOK_INIT(task_to_inode, vsentry_task_to_inode),
+	LSM_HOOK_INIT(ipc_permission, vsentry_ipc_permission),
+	LSM_HOOK_INIT(ipc_getsecid, vsentry_ipc_getsecid),
+	LSM_HOOK_INIT(msg_msg_alloc_security, vsentry_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security, vsentry_msg_msg_free_security),
+	LSM_HOOK_INIT(msg_queue_alloc_security,
+		vsentry_msg_queue_alloc_security),
+	LSM_HOOK_INIT(msg_queue_free_security,
+		vsentry_msg_queue_free_security),
+	LSM_HOOK_INIT(msg_queue_associate, vsentry_msg_queue_associate),
+	LSM_HOOK_INIT(msg_queue_msgctl, vsentry_msg_queue_msgctl),
+	LSM_HOOK_INIT(msg_queue_msgsnd, vsentry_msg_queue_msgsnd),
+	LSM_HOOK_INIT(msg_queue_msgrcv, vsentry_msg_queue_msgrcv),
+	LSM_HOOK_INIT(shm_alloc_security, vsentry_shm_alloc_security),
+	LSM_HOOK_INIT(shm_free_security, vsentry_shm_free_security),
+	LSM_HOOK_INIT(shm_associate, vsentry_shm_associate),
+	LSM_HOOK_INIT(shm_shmctl, vsentry_shm_shmctl),
+	LSM_HOOK_INIT(shm_shmat, vsentry_shm_shmat),
+	LSM_HOOK_INIT(sem_alloc_security, vsentry_sem_alloc_security),
+	LSM_HOOK_INIT(sem_free_security, vsentry_sem_free_security),
+	LSM_HOOK_INIT(sem_associate, vsentry_sem_associate),
+	LSM_HOOK_INIT(sem_semctl, vsentry_sem_semctl),
+	LSM_HOOK_INIT(sem_semop, vsentry_sem_semop),
+	LSM_HOOK_INIT(netlink_send, vsentry_netlink_send),
+	LSM_HOOK_INIT(d_instantiate, vsentry_d_instantiate),
+	LSM_HOOK_INIT(getprocattr, vsentry_getprocattr),
+	LSM_HOOK_INIT(setprocattr, vsentry_setprocattr),
+	LSM_HOOK_INIT(ismaclabel, vsentry_ismaclabel),
+	LSM_HOOK_INIT(secid_to_secctx, vsentry_secid_to_secctx),
+	LSM_HOOK_INIT(secctx_to_secid, vsentry_secctx_to_secid),
+	LSM_HOOK_INIT(release_secctx, vsentry_release_secctx),
+	LSM_HOOK_INIT(inode_invalidate_secctx,
+		vsentry_inode_invalidate_secctx),
+	LSM_HOOK_INIT(inode_notifysecctx, vsentry_inode_notifysecctx),
+	LSM_HOOK_INIT(inode_setsecctx, vsentry_inode_setsecctx),
+	LSM_HOOK_INIT(inode_getsecctx, vsentry_inode_getsecctx),
+#endif
+#ifdef CONFIG_SECURITY_NETWORK
+#if 0
+	LSM_HOOK_INIT(unix_stream_connect, vsentry_unix_stream_connect),
+	LSM_HOOK_INIT(unix_may_send, vsentry_unix_may_send),
+	LSM_HOOK_INIT(socket_create, vsentry_socket_create),
+#endif
+	LSM_HOOK_INIT(socket_post_create, vsentry_socket_post_create),
+#if 0
+	LSM_HOOK_INIT(socket_bind, vsentry_socket_bind),
+	LSM_HOOK_INIT(socket_connect, vsentry_socket_connect),
+	LSM_HOOK_INIT(socket_listen, vsentry_socket_listen),
+#endif
+	LSM_HOOK_INIT(socket_accept, vsentry_socket_accept),
+	LSM_HOOK_INIT(socket_sendmsg, vsentry_socket_sendmsg),
+#if 0
+	LSM_HOOK_INIT(socket_recvmsg, vsentry_socket_recvmsg),
+	LSM_HOOK_INIT(socket_getsockname, vsentry_socket_getsockname),
+	LSM_HOOK_INIT(socket_getpeername, vsentry_socket_getpeername),
+	LSM_HOOK_INIT(socket_getsockopt, vsentry_socket_getsockopt),
+	LSM_HOOK_INIT(socket_setsockopt, vsentry_socket_setsockopt),
+	LSM_HOOK_INIT(socket_shutdown, vsentry_socket_shutdown),
+#endif
+	LSM_HOOK_INIT(socket_sock_rcv_skb, vsentry_socket_sock_rcv_skb),
+#if 0
+	LSM_HOOK_INIT(socket_getpeersec_stream,
+		vsentry_socket_getpeersec_stream),
+	LSM_HOOK_INIT(socket_getpeersec_dgram,
+		vsentry_socket_getpeersec_dgram),
+	LSM_HOOK_INIT(sk_alloc_security, vsentry_sk_alloc_security),
+	LSM_HOOK_INIT(sk_free_security, vsentry_sk_free_security),
+	LSM_HOOK_INIT(sk_clone_security, vsentry_sk_clone_security),
+	LSM_HOOK_INIT(sk_getsecid, vsentry_sk_getsecid),
+	LSM_HOOK_INIT(sock_graft, vsentry_sock_graft),
+	LSM_HOOK_INIT(inet_conn_request, vsentry_inet_conn_request),
+	LSM_HOOK_INIT(inet_csk_clone, vsentry_inet_csk_clone),
+	LSM_HOOK_INIT(inet_conn_established, vsentry_inet_conn_established),
+	LSM_HOOK_INIT(secmark_relabel_packet, vsentry_secmark_relabel_packet),
+	LSM_HOOK_INIT(secmark_refcount_inc, vsentry_secmark_refcount_inc),
+	LSM_HOOK_INIT(secmark_refcount_dec, vsentry_secmark_refcount_dec),
+	LSM_HOOK_INIT(req_classify_flow, vsentry_req_classify_flow),
+	LSM_HOOK_INIT(tun_dev_alloc_security, vsentry_tun_dev_alloc_security),
+	LSM_HOOK_INIT(tun_dev_free_security, vsentry_tun_dev_free_security),
+	LSM_HOOK_INIT(tun_dev_create, vsentry_tun_dev_create),
+	LSM_HOOK_INIT(tun_dev_attach_queue, vsentry_tun_dev_attach_queue),
+	LSM_HOOK_INIT(tun_dev_attach, vsentry_tun_dev_attach),
+	LSM_HOOK_INIT(tun_dev_open, vsentry_tun_dev_open),
+#endif
+#endif  /* CONFIG_SECURITY_NETWORK */
+#ifdef CONFIG_SECURITY_NETWORK_XFRM
+#if 0
+	LSM_HOOK_INIT(xfrm_policy_alloc_security,
+		vsentry_xfrm_policy_alloc_security),
+	LSM_HOOK_INIT(xfrm_policy_clone_security,
+		vsentry_xfrm_policy_clone_security),
+	LSM_HOOK_INIT(xfrm_policy_free_security,
+		vsentry_xfrm_policy_free_security),
+	LSM_HOOK_INIT(xfrm_policy_delete_security,
+		vsentry_xfrm_policy_delete_security),
+	LSM_HOOK_INIT(xfrm_state_alloc, vsentry_xfrm_state_alloc),
+	LSM_HOOK_INIT(xfrm_state_alloc_acquire,
+		vsentry_xfrm_state_alloc_acquire),
+	LSM_HOOK_INIT(xfrm_state_free_security,
+		vsentry_xfrm_state_free_security),
+	LSM_HOOK_INIT(xfrm_state_delete_security,
+		vsentry_xfrm_state_delete_security),
+	LSM_HOOK_INIT(xfrm_policy_lookup, vsentry_xfrm_policy_lookup),
+	LSM_HOOK_INIT(xfrm_state_pol_flow_match,
+		vsentry_xfrm_state_pol_flow_match),
+	LSM_HOOK_INIT(xfrm_decode_session, vsentry_xfrm_decode_session),
+#endif
+#endif
+};
+
+/***********************************************************************
+ * function:     vsentry_lsm_init
+ * description:  init and register vsentry hooks to LSM.
+ * in param:     n/a
+ * out param:    n/a
+ * return:       0
+ **********************************************************************/
+static int __init vsentry_lsm_init(void)
+{
+	int i;
+
+	for (i = 0; i < MAP_SIZE; i++) {
+		INIT_HLIST_HEAD(&socket_process_map[i]);
+		INIT_HLIST_HEAD(&super_block_map[i]);
+	}
+
+	security_add_hooks(vsentry_default_lsm_hooks,
+		ARRAY_SIZE(vsentry_default_lsm_hooks));
+
+	vs_hook_info("vSentry security module initialized\n");
+
+	return 0;
+}
+
+security_initcall(vsentry_lsm_init);
+
+/***********************************************************************
+ * function:     vsentry_ipv4_hook_post_routing
+ * description:  we use this hook to classify all outgoing tcp/ip traffic.
+ * in param:     struct sk_buff *skb - outgoing buffer
+ * out param:    n/a
+ * return:       NF_ACCEPT/NF_DROP
+ **********************************************************************/
+static unsigned int vsentry_ipv4_hook_post_routing(void *priv,
+	struct sk_buff *skb, const struct nf_hook_state *state)
+{
+	int ret = NF_DROP;
+	vsentry_event_t ev;
+	struct iphdr *ip_header = (struct iphdr *)skb_network_header(skb);
+
+	if (!vsentry_get_enable())
+		return NF_ACCEPT;
+
+	/* classify only TCP/UDP */
+	if (ip_header->protocol != IPPROTO_TCP &&
+			ip_header->protocol != IPPROTO_UDP)
+		return NF_ACCEPT;
+
+	vs_hook_dbg("classify tx net\n");
+
+	memset(&ev, 0, sizeof(vsentry_event_t));
+
+	ev.ip_event.ip_proto = ip_header->protocol;
+	ev.dir = DIR_OUT;
+	ev.ts = vsentry_get_curr_time_usec();
+
+	vsentry_extract_ip_info(&ev.ip_event, skb);
+
+	if (skb->sk && skb->sk->sk_socket)
+		get_id_by_socket(skb->sk->sk_socket, &ev.event_id);
+	else
+		ev.event_id.kernel = true;
+
+	if (vsentry_check_event(VSENTRY_IP_EVENT, &ev, true) == VSENTRY_SUCCESS)
+		ret = NF_ACCEPT;
+
+	if (ev.event_id.exec_name)
+		free_name(ev.event_id.exec_name);
+
+	return ret;
+}
+
+static const struct nf_hook_ops vsentry_nf_ops[] = {
+	{
+		.hook =		vsentry_ipv4_hook_post_routing,
+		.pf =		NFPROTO_IPV4,
+		.hooknum =	NF_INET_POST_ROUTING,
+		.priority =	NF_IP_PRI_FIRST,
+	},
+};
+
+/***********************************************************************
+ * function:     vsentry_nf_register
+ * description:  register to NF hooks.
+ * in param:     struct net *net
+ * out param:    n/a
+ * return:
+ **********************************************************************/
+static int __net_init vsentry_nf_register(struct net *net)
+{
+	return nf_register_net_hooks(net, vsentry_nf_ops,
+				     ARRAY_SIZE(vsentry_nf_ops));
+}
+
+/***********************************************************************
+ * function:     vsentry_nf_unregister
+ * description:  unregister from NF hooks.
+ * in param:     struct net *net
+ * out param:    n/a
+ * return:
+ **********************************************************************/
+static void __net_exit vsentry_nf_unregister(struct net *net)
+{
+	nf_unregister_net_hooks(net, vsentry_nf_ops,
+				ARRAY_SIZE(vsentry_nf_ops));
+}
+
+static struct pernet_operations vsentry_net_ops = {
+	.init = vsentry_nf_register,
+	.exit = vsentry_nf_unregister,
+};
+
+/***********************************************************************
+ * function:     vsentry_nf_init
+ * description:
+ * in param:
+ * out param:
+ * return:
+ **********************************************************************/
+static int __init vsentry_nf_init(void)
+{
+	int err;
+
+	err = register_pernet_subsys(&vsentry_net_ops);
+	if (err)
+		panic("register_pernet_subsys: error %d\n", err);
+
+	vs_hook_info("Registered vSentry netfilter hooks\n");
+
+	return 0;
+}
+__initcall(vsentry_nf_init);
diff --git a/security/vsentry/vsentry_internal.h b/security/vsentry/vsentry_internal.h
new file mode 100644
index 000000000000..eb69b8eca949
--- /dev/null
+++ b/security/vsentry/vsentry_internal.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2018 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __VSENTRY_INTERNAL_H__
+#define __VSENTRY_INTERNAL_H__
+
+int   vsentry_set_eng_tgid(unsigned int pid);
+int   vsentry_get_eng_tgid(void);
+int   vsentry_update_shmem(char *dbfile);
+int   vsentry_update_execmem(char *execfile);
+bool  vsentry_get_enable(void);
+int   vsentry_set_enable(bool enable);
+int   vsentry_set_mode(unsigned int mode);
+int   vsentry_get_state(struct vsentry_state *state);
+int   vsentry_set_file_cls_mode(unsigned int mode);
+int   vsentry_get_file_cls_mode(void);
+void  vsentry_print_info(void);
+void  vsentry_cls_remove_inode(unsigned long inode);
+int   vsentry_check_event(vsentry_ev_type_e type, vsentry_event_t *ev, bool atomic);
+int   vsentry_generate_netlink_event(vsentry_event_t *ev);
+unsigned long long vsentry_get_curr_time_usec(void);
+int   vsentry_copy_shmem(char *dbfile);
+//void  vsentry_shutdown(void);
+
+#endif /* __VSENTRY_INTERNAL_H__ */
diff --git a/security/vsentry/vsentry_mod.c b/security/vsentry/vsentry_mod.c
new file mode 100644
index 000000000000..fae3bf7b11cb
--- /dev/null
+++ b/security/vsentry/vsentry_mod.c
@@ -0,0 +1,825 @@
+/* Copyright (C) 2019 SafeRide, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/cpumask.h>
+#include <linux/kernel_stat.h>
+#include <linux/tick.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/vsentry/vsentry.h>
+#include <linux/vsentry/vsentry_drv.h>
+#include "vsentry_internal.h"
+
+#define CLS_BIN_FILE 	"/etc/vsentry/cls.bin"
+#define CLS_DB_FILE 	"/etc/vsentry/db.mem"
+
+//#define VS_MOD_DEBUG
+#ifdef VS_MOD_DEBUG
+#define vs_dbg(fmt, ...) \
+	pr_debug("[DBG] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#else
+#define vs_dbg(...)
+#endif /* VS_MOD_DEBUG */
+
+#define vs_err(fmt, ...) \
+	pr_err("[ERR] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#define vs_warn(fmt, ...) \
+	pr_warn("[WRN] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+#define vs_info(fmt, ...) \
+	pr_info("[INF] %llu %s: " fmt, vsentry_get_curr_time_usec(), \
+		__func__, ##__VA_ARGS__)
+
+static int vsentry_eng_tgid;
+static volatile bool vsentry_enabled;
+static unsigned int file_cls_mode = FILE_CLS_MODE_STR;
+static void *shmem, *execmem;
+static unsigned int shmem_size = 0;
+static volatile bool db_update;
+static volatile unsigned int usage;
+static int (* volatile cls_func)(vsentry_ev_type_e ev_type, vsentry_event_t *event);
+
+static DEFINE_SPINLOCK(vsentry_lock);
+
+/***********************************************************************
+ * function:    vsentry_get_curr_time_usec
+ * description: aux function. get the current time in usecs
+ * in param:    n/a
+ * out param:   n/a.
+ * return:      unsigned long long time in usecs
+ **********************************************************************/
+unsigned long long vsentry_get_curr_time_usec(void)
+{
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+
+	return ((tv.tv_sec * 1000000) + tv.tv_usec);
+}
+
+/***********************************************************************
+ * function:    vsentry_set_eng_pid
+ * description: register the vsentry engine pid. this will help us skip
+ *              security checks on operations made by the engine.
+ * in param:    unsigned int pid
+ * out param:   n/a.
+ * return:      0 on success, other on failure.
+ **********************************************************************/
+int vsentry_set_eng_tgid(unsigned int pid)
+{
+	if (vsentry_eng_tgid && pid) {
+		vs_err("another engine already registered\n");
+		return VSENTRY_ALREADY_EXISTS;
+	}
+
+	vsentry_eng_tgid = pid;
+
+	vs_dbg("set eng pid %u\n", vsentry_eng_tgid);
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_get_eng_pid
+ * description: return the current engine pid.
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      int - engine pid.
+ **********************************************************************/
+int vsentry_get_eng_tgid(void)
+{
+	return vsentry_eng_tgid;
+}
+
+/***********************************************************************
+ * function:    update_mem_from_file
+ * description: copy file content to memory area.
+ * in param:    char *filename - file to copy
+ *              bool executable - is memory should be executable
+ * out param:   n/a.
+ * return:      void* (memory pointer or error)
+ **********************************************************************/
+void* update_mem_from_file(char *filename, bool executable)
+{
+	struct file *f = NULL;
+	loff_t offset = 0, f_size, m_size;
+	int ret = VSENTRY_SUCCESS;
+	void *tmp = NULL;
+
+	vs_dbg("updating %s from file %s\n", executable?"EXEC":"DB", filename);
+
+	/* open the file */
+	f = filp_open(filename, O_RDONLY, 0644);
+	if (IS_ERR(f)) {
+		vs_err("failed to open %s\n", filename);
+		return ERR_PTR(-ENOENT);
+	}
+
+	/* get the file size */
+	f_size = i_size_read(f->f_inode);
+	if (f_size <= 0) {
+		vs_err("invalid file size %llu\n", f_size);
+		ret = -EINVAL;
+		goto update_err;
+	}
+
+	/* align to page size */
+	m_size = f_size;
+	if (m_size % PAGE_SIZE)
+		m_size = ((m_size & PAGE_MASK) + PAGE_SIZE);
+
+	vs_dbg("aligned memory size 0x%llx\n", m_size);
+
+	if (executable)
+		tmp = vmalloc_exec(m_size);
+	else
+		tmp = __vmalloc(m_size, GFP_USER | __GFP_ZERO, PAGE_KERNEL);
+
+	/* TODO: modify the pages to R/X. see exmaple in
+	 * module_enable_ro(mod, false);
+	 * module_enable_nx(mod);
+	 */
+
+	if (!tmp) {
+		vs_err("failed to alloc pages\n");
+		ret = -ENOMEM;
+		goto update_err;
+	}
+
+	vs_info("allocated %s mem 0x%px length 0x%llx\n",
+			executable?"EXEC":"DB", tmp, m_size);
+
+	/* read file content to memory */
+	ret = kernel_read(f, offset, tmp, f_size);
+	if (ret != f_size) {
+		vs_err("failed to read %s. expected %d actual %d\n",
+				filename, (int)f_size, ret);
+		ret = -EIO;
+		goto update_err;
+	}
+
+	filp_close(f, NULL);
+
+	if (!executable)
+		shmem_size = f_size;
+
+	/* memory is ready */
+	return tmp;
+
+update_err:
+	if (f)
+		filp_close(f, NULL);
+
+	if (tmp)
+		vfree(tmp);
+
+	return ERR_PTR(ret);
+}
+
+/***********************************************************************
+ * function:    vsentry_mod_init
+ * description: init function. called by kernel init after root file-system
+ *              is up.
+ * in param:    n/a
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/error
+ **********************************************************************/
+int vsentry_mod_init(void)
+{
+	int mode = VSENTRY_MODE_ENFORCE;
+
+	if (vsentry_update_execmem(CLS_BIN_FILE) != VSENTRY_SUCCESS)
+		return -EIO;
+
+	if (vsentry_update_shmem(CLS_DB_FILE) != VSENTRY_SUCCESS) {
+		shmem = __vmalloc(SHMEM_BUFFER_SIZE, GFP_USER |
+				__GFP_ZERO, PAGE_KERNEL);
+		/* if we don't have DB yet, we can start with empty DB */
+		if (!shmem) {
+			vs_err("failed to initialize DB\n");
+			return PTR_ERR(shmem);
+		}
+
+		shmem_size = SHMEM_BUFFER_SIZE;
+
+		/* initialize classifier DB */
+		cls_func(VSENTRY_CLASIFFIER_INIT, shmem);
+
+		vs_info("setting learn mode\n");
+		mode = VSENTRY_MODE_LEARN;
+		vsentry_set_mode(mode);
+	}
+
+	/* to avoid logging overload upon init */
+	cls_func(VSENTRY_REGISTER_PRINTF, NULL);
+
+	if (vsentry_set_enable(true) != VSENTRY_SUCCESS)
+		return -EPERM;
+
+	vs_info("vsentry initialized\n");
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_update_shmem
+ * description: this function will update the DB with a new content
+ *              from a file.
+ * in param:    char *dbfile
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/error
+ **********************************************************************/
+int vsentry_update_shmem(char *dbfile)
+{
+	unsigned long flags;
+	void *tmp_shmem = update_mem_from_file(dbfile, false);
+
+	if (IS_ERR(tmp_shmem))
+		return PTR_ERR(tmp_shmem);
+
+	/* disable interrupts on this cpu */
+	spin_lock_irqsave(&vsentry_lock, flags);
+
+	/* signal update is on the way */
+	db_update = true;
+
+	/* wait till all ongoing checks will complete */
+	while (usage)
+		;
+
+	if (cls_func) {
+		unsigned int mode = VSENTRY_MODE_TOTAL;
+
+		/* init the classifier with the new DB */
+		cls_func(VSENTRY_CLASIFFIER_INIT, tmp_shmem);
+
+		/* align with new mode */
+		cls_func(VSENTRY_CLASIFFIER_GET_MODE, (void *)&mode);
+		if (mode == VSENTRY_MODE_LEARN)
+			file_cls_mode = FILE_CLS_MODE_STR;
+	}
+
+	db_update = false;
+
+	/* enable interrupts on this cpu */
+	spin_unlock_irqrestore(&vsentry_lock, flags);
+
+	/* cls was updated, free old DB */
+	if (shmem)
+		vfree(shmem);
+	shmem = tmp_shmem;
+
+	vs_dbg("DB update was completed successfully\n");
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_copy_shmem
+ * description: this function will copy the DB to a file.
+ * in param:    char *dbfile
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/error
+ **********************************************************************/
+int vsentry_copy_shmem(char *dbfile)
+{
+	struct file *f = NULL;
+	int ret = VSENTRY_SUCCESS;
+	bool is_enabled = vsentry_enabled;
+	unsigned int mode = VSENTRY_MODE_TOTAL;
+	bool modified = false;
+
+	if (!shmem || !shmem_size) {
+		vs_err("DB is not initialized\n");
+		return -EPERM;
+	}
+
+	/* open the file */
+	f = filp_open(dbfile, O_RDWR | O_CREAT, 0644);
+	if (IS_ERR(f)) {
+		vs_err("failed to open %s\n", dbfile);
+		return -ENOENT;
+	}
+
+	/* TODO: add lock to avoid miss-configuration (ioctl, etc) */
+	vsentry_enabled = false;
+
+	/* wait until all ongoing checks will complete */
+	while (usage)
+		;
+
+	/* get the current cls mode */
+	if (cls_func) {
+		cls_func(VSENTRY_CLASIFFIER_GET_MODE, (void *)&mode);
+
+		if (mode == VSENTRY_MODE_LEARN) {
+			unsigned int new_mode = VSENTRY_MODE_PERMISSIVE;
+
+			/* to avoid memory loss in the DB switch to permissive mode */
+			ret = cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&new_mode);
+			if (ret != VSENTRY_SUCCESS && ret != VSENTRY_ALREADY_EXISTS) {
+				vs_err("failed to set classifier mode to %u\n", mode);
+				vsentry_enabled = is_enabled;
+				return -EIO;
+			}
+
+			modified = true;
+		}
+	}
+
+	vs_dbg("copy DB to file %s\n", dbfile);
+
+	ret = kernel_write(f, shmem, shmem_size, 0);
+	if (ret != shmem_size) {
+		vs_err("failed to write %s. expected %d actual %d\n",
+			dbfile, (int)shmem_size, ret);
+		ret = -EIO;
+	} else {
+		vs_dbg("DB copy was completed successfully\n");
+	}
+
+	filp_close(f, NULL);
+
+	/* restore the current cls mode */
+	if (cls_func && modified) {
+		ret = cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&mode);
+		if (ret != VSENTRY_SUCCESS && ret != VSENTRY_ALREADY_EXISTS) {
+			vs_err("failed to set classifier mode to %u\n", mode);
+			ret = -EIO;
+		}
+	}
+
+	vsentry_enabled = is_enabled;
+
+	return ret;
+}
+
+/***********************************************************************
+ * function:    vsentry_shutdown
+ * description: called when system is going down. if we are in learn
+ *              write DB to file. set to permissive mode.
+ * in param:    n/a
+ * out param:   n/a
+ * return:      n/a
+ **********************************************************************/
+//void vsentry_shutdown(void)
+//{
+//	int ret = VSENTRY_SUCCESS;
+//	unsigned int mode;
+//
+//	if (!shmem || !shmem_size) {
+//		vs_err("DB is not initialized\n");
+//		return;
+//	}
+//
+//	vsentry_enabled = false;
+//
+//	/* wait until all ongoing checks will complete */
+//	while (usage)
+//		;
+//
+//	cls_func(VSENTRY_CLASIFFIER_GET_MODE, (void *)&mode);
+//	if (mode == VSENTRY_MODE_LEARN) {
+//		unsigned int new_mode = VSENTRY_MODE_PERMISSIVE;
+//
+//		/* to avoid memory loss in the DB switch to permissive mode */
+//		ret = cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&new_mode);
+//		if (ret != VSENTRY_SUCCESS && ret != VSENTRY_ALREADY_EXISTS) {
+//			vs_err("failed to set classifier mode to %u\n", mode);
+//			return;
+//		}
+//	}
+//	/* set to permissive mode */
+//	ret = cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&mode);
+//	if (ret != VSENTRY_SUCCESS && ret != VSENTRY_ALREADY_EXISTS) {
+//		vs_err("failed to set classifier mode to %u\n", mode);
+//		return;
+//	}
+//
+//	vsentry_copy_shmem(CLS_DB_FILE);
+//}
+/***********************************************************************
+ * function:    vsentry_update_execmem
+ * description: this function will update the EXEC with a new content
+ *              from a file.
+ * in param:    char *execfile
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/error
+ **********************************************************************/
+int vsentry_update_execmem(char *execfile)
+{
+	unsigned long flags;
+	void *tmp_execmem = update_mem_from_file(execfile, true);
+	bool modified = false;
+	unsigned int mode = VSENTRY_MODE_TOTAL;
+
+	if (IS_ERR(tmp_execmem)) {
+		vs_err("failed to update new EXEC\n");
+		return PTR_ERR(tmp_execmem);
+	}
+
+	/* disable interrupts on this cpu */
+	spin_lock_irqsave(&vsentry_lock, flags);
+
+	/* signal update is on the way */
+	db_update = true;
+
+	/* wait until all ongoing checks will complete */
+	while (usage)
+		;
+
+	if (shmem) {
+		cls_func(VSENTRY_CLASIFFIER_GET_MODE, (void *)&mode);
+		if (mode == VSENTRY_MODE_LEARN) {
+			unsigned int new_mode = VSENTRY_MODE_PERMISSIVE;
+
+			/* to avoid memory loss in the DB switch to permissive mode */
+			cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&new_mode);
+			modified = true;
+		}
+	}
+
+	/* point to the new EXEC */
+	cls_func = (int (*)(vsentry_ev_type_e ev_type, vsentry_event_t *event))tmp_execmem;
+	cls_func(VSENTRY_REGISTER_PRINTF, (void *)printk);
+	if (shmem) {
+		/* initialize classifier DB */
+		cls_func(VSENTRY_CLASIFFIER_INIT, shmem);
+
+		if (modified)
+			/* restore prev mode */
+			cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&mode);
+	}
+
+	db_update = false;
+
+	/* enable interrupts on this cpu */
+	spin_unlock_irqrestore(&vsentry_lock, flags);
+
+	/* EXEC was updated, free previous EXEC */
+	vfree(execmem);
+	execmem = tmp_execmem;
+
+	vs_dbg("EXEC update was completed successfully\n");
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_get_enable
+ * description: get the vsentry module state
+ * in param:    n/a.
+ * out param:   n/a.
+ * return:      true/false.
+ **********************************************************************/
+bool vsentry_get_enable(void)
+{
+	return vsentry_enabled;
+}
+
+/***********************************************************************
+ * function:    vsentry_set_enable
+ * description: senble/disable vsentry module
+ * in param:    bool enable.
+ * out param:   n/a.
+ * return:      0 on success.
+ **********************************************************************/
+int vsentry_set_enable(bool enable)
+{
+	if (vsentry_enabled == enable) {
+		vs_dbg("vsentry already %s\n",
+			vsentry_enabled?"enabled":"disabled");
+		return VSENTRY_SUCCESS;
+	}
+
+	if (enable) {
+		if (!shmem) {
+			vs_err("DB is not initialized\n");
+			return -EPERM;
+		}
+
+		if (!cls_func) {
+			vs_err("EXEC is not initialized\n");
+			return -EPERM;
+		}
+	}
+
+	vsentry_enabled = enable;
+
+	vs_dbg("vsentry is %s\n", vsentry_enabled?"enabled":"disabled");
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_set_mode
+ * description: set the classifier mode (learn/permissive/enforce)
+ * in param:    unsigned int mode
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/ negtive on error
+ **********************************************************************/
+int vsentry_set_mode(unsigned int mode)
+{
+	int ret;
+
+	if (!shmem || !cls_func) {
+		vs_err("vsentry is not initialized\n");
+		return -EPERM;
+	}
+
+	vs_dbg("set vsentry mode %d\n", mode);
+
+	ret = cls_func(VSENTRY_CLASIFFIER_SET_MODE, (void *)&mode);
+	if (ret != VSENTRY_SUCCESS && ret != VSENTRY_ALREADY_EXISTS) {
+		vs_err("failed to set classifier mode to %u\n", mode);
+		return -EIO;
+	}
+
+	if (mode == VSENTRY_MODE_LEARN)
+		vsentry_set_file_cls_mode(FILE_CLS_MODE_STR);
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_get_state
+ * description: get the classifier and hooks state
+ * in param:    unsigned int mode
+ * out param:   struct vsentry_state *state
+ * return:      VSENTRY_SUCCESS
+ **********************************************************************/
+int vsentry_get_state(struct vsentry_state *state)
+{
+	if (!state)
+		return -EIO;
+
+	if (shmem && cls_func)
+		cls_func(VSENTRY_CLASIFFIER_GET_MODE, (void *)&state->mode);
+	else
+		state->mode = VSENTRY_MODE_TOTAL;
+
+	state->enabled = vsentry_enabled;
+	state->cls_present = (execmem?true:false);
+	state->db_present = (shmem?true:false);
+	state->file_cls_mode = file_cls_mode;
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_set_file_cls_mode
+ * description: set the file classification mode (string/inode)
+ * in param:    unsigned int mode
+ * out param:   n/a
+ * return:      VSENTRY_SUCCESS/-EINVAL
+ **********************************************************************/
+int vsentry_set_file_cls_mode(unsigned int mode)
+{
+	if (file_cls_mode >= FILE_CLS_MODE_MAX)
+		return -EINVAL;
+
+	file_cls_mode = mode;
+
+	vs_info("set vsentry file_cls_mode %s\n",
+		file_cls_mode==FILE_CLS_MODE_STR?"string":"inode");
+
+	return VSENTRY_SUCCESS;
+}
+
+/***********************************************************************
+ * function:    vsentry_get_file_cls_mode
+ * description: get the current file classification mode
+ * in param:    n/a
+ * out param:   n/a
+ * return:      int
+ **********************************************************************/
+int vsentry_get_file_cls_mode(void)
+{
+	return file_cls_mode;
+}
+
+/***********************************************************************
+ * function:    vsentry_print_info
+ * description: print the current classifier DB and state
+ * in param:    n/a
+ * out param:   n/a
+ * return:      n/a
+ **********************************************************************/
+void vsentry_print_info(void)
+{
+	if (!shmem || !cls_func) {
+		vs_err("vsentry is not initialized\n");
+		return;
+	}
+
+	cls_func(VSENTRY_PRINT_INFO, NULL);
+}
+
+/***********************************************************************
+ * function:    vsentry_cls_remove_inode
+ * description: update the classifier DB with removed inode
+ * in param:    unsigned long inode
+ * out param:   n/a
+ * return:      n/a
+ **********************************************************************/
+void vsentry_cls_remove_inode(unsigned long inode)
+{
+	if (vsentry_enabled)
+		cls_func(VSENTRY_REMOVE_INODE, (void *)&inode);
+}
+
+#ifdef VS_MOD_DEBUG
+
+void vsentry_print_ip_event(vsentry_event_t *ip_event)
+{
+	vs_err("uid %u prog %s (inode %lu) dir %s src %d.%d.%d.%d sport %d dst %d.%d.%d.%d dport %d proto %d\n",
+		ip_event->event_id.kernel?0:ip_event->event_id.uid,
+		ip_event->event_id.kernel?"kernel":(ip_event->event_id.exec_name?ip_event->event_id.exec_name:""),
+		ip_event->event_id.exec_ino,
+		(ip_event->dir == DIR_IN)?"in":"out",
+		(ip_event->ip_event.saddr.v4addr & 0xFF000000)>>24,
+		(ip_event->ip_event.saddr.v4addr & 0xFF0000)>>16,
+		(ip_event->ip_event.saddr.v4addr & 0xFF00)>>8,
+		(ip_event->ip_event.saddr.v4addr & 0xFF),
+		ip_event->ip_event.sport,
+		(ip_event->ip_event.daddr.v4addr & 0xFF000000)>>24,
+		(ip_event->ip_event.daddr.v4addr & 0xFF0000)>>16,
+		(ip_event->ip_event.daddr.v4addr & 0xFF00)>>8,
+		(ip_event->ip_event.daddr.v4addr & 0xFF),
+		ip_event->ip_event.dport,
+		ip_event->ip_event.ip_proto);
+}
+
+void vsentry_print_can_event(vsentry_event_t *can_event)
+{
+	vs_err("uid %u prog %s (inode %lu) msgid 0x%x dir %s if %u\n",
+		can_event->event_id.kernel?0:can_event->event_id.uid,
+		can_event->event_id.kernel?"kernel":(can_event->event_id.exec_name?can_event->event_id.exec_name:""),
+		can_event->event_id.exec_ino,
+		can_event->can_event.can_header.msg_id,
+		(can_event->dir == DIR_IN)?"in":"out",
+		can_event->can_event.can_header.if_index);
+}
+
+void vsentry_print_file_event(vsentry_event_t *file_event)
+{
+	switch (file_event->file_event.type) {
+	case FILE_TYPE_SYSFS:
+		vs_err("uid %u prog %s (%lu) file SYSFS (%lu) mode %s%s%s\n",
+			file_event->event_id.kernel?0:file_event->event_id.uid,
+			file_event->event_id.kernel?"kernel":(file_event->event_id.exec_name?file_event->event_id.exec_name:""),
+			file_event->event_id.exec_ino,
+			file_event->file_event.file_ino,
+			(file_event->file_event.mode & FILE_MODE_READ)?"r":"",
+			(file_event->file_event.mode & FILE_MODE_WRITE)?"w":"",
+			(file_event->file_event.mode & FILE_MODE_EXEC)?"x":"");
+		break;
+	case FILE_TYPE_PROCFS:
+		vs_err("uid %u prog %s (%lu) file PROCFS (%lu) mode %s%s%s\n",
+			file_event->event_id.kernel?0:file_event->event_id.uid,
+			file_event->event_id.kernel?"kernel":(file_event->event_id.exec_name?file_event->event_id.exec_name:""),
+			file_event->event_id.exec_ino,
+			file_event->file_event.file_ino,
+			(file_event->file_event.mode & FILE_MODE_READ)?"r":"",
+			(file_event->file_event.mode & FILE_MODE_WRITE)?"w":"",
+			(file_event->file_event.mode & FILE_MODE_EXEC)?"x":"");
+		break;
+	case FILE_TYPE_REG:
+		vs_err("uid %u prog %s (%lu) file %s (%lu) mode %s%s%s\n",
+			file_event->event_id.kernel?0:file_event->event_id.uid,
+			file_event->event_id.kernel?"kernel":(file_event->event_id.exec_name?file_event->event_id.exec_name:""),
+			file_event->event_id.exec_ino,
+			file_event->file_event.filename?file_event->file_event.filename:"",
+			file_event->file_event.file_ino,
+			(file_event->file_event.mode & FILE_MODE_READ)?"r":"",
+			(file_event->file_event.mode & FILE_MODE_WRITE)?"w":"",
+			(file_event->file_event.mode & FILE_MODE_EXEC)?"x":"");
+		break;
+	default:
+		break;
+	}
+}
+
+static void cls_print_action(unsigned int action_bitmap)
+{
+	bool log = false;
+	bool drop = true;
+	bool learn = false;
+
+	if (action_bitmap & VSENTRY_ACTION_ALLOW)
+		drop = false;
+
+	if (action_bitmap & VSENTRY_ACTION_LOG)
+		log = true;
+
+	if (action_bitmap & VSENTRY_ACTION_LEARN)
+		learn = true;
+
+	vs_dbg("cls_func return %s%s%s\n", drop?"drop":"allow", log?",log":"", learn?"learn":"");
+}
+#endif
+
+/***********************************************************************
+ * function:    vsentry_check_event
+ * description: security check the event.
+ * in param:    vsentry_ev_type_e type - event type
+ *              vsentry_event_t *ev - the event info
+ *              bool atomic - is this atomic/interrupt context
+ * out param:   n/a
+ * return:      VSENTRY_ERROR/VSENTRY_SUCCESS/etc ..
+ **********************************************************************/
+//#define TIMECHECK
+#ifdef TIMECHECK
+static DEFINE_SPINLOCK(time_check_lock);
+#endif
+
+int vsentry_check_event(vsentry_ev_type_e type, vsentry_event_t *ev, bool atomic)
+{
+	int ret = VSENTRY_ERROR;
+#ifdef TIMECHECK
+	unsigned long flags;
+#endif
+	if (!vsentry_enabled)
+		return VSENTRY_SUCCESS;
+
+#ifdef TIMECHECK
+	spin_lock_irqsave(&time_check_lock, flags);
+#endif
+
+	/* update usage counter */
+	__sync_add_and_fetch(&usage, 1);
+
+	/* wait until update finish */
+	while (db_update) {
+		__sync_sub_and_fetch(&usage, 1);
+		udelay(1);
+		__sync_add_and_fetch(&usage, 1);
+	}
+
+retry:
+	if (cls_func) {
+		ret = cls_func(type, ev);
+		if (ret == VSENTRY_BUSY && !atomic) {
+			if (schedule_timeout_interruptible(usecs_to_jiffies(1)))
+				ret = VSENTRY_ERROR;
+			else
+				goto retry;
+		}
+	}
+
+	/* update usage counter */
+	__sync_sub_and_fetch(&usage, 1);
+
+	/* logging ? */
+	if (ev->act_bitmap & VSENTRY_ACTION_LOG)
+		vsentry_generate_netlink_event(ev);
+
+	/* event when cls return success the decision might be drop */
+	if (ret == VSENTRY_SUCCESS) {
+		if (!(ev->act_bitmap & VSENTRY_ACTION_ALLOW))
+			ret = VSENTRY_ERROR;
+	}
+
+#ifdef VS_MOD_DEBUG
+	if (ret != VSENTRY_SUCCESS) {
+		switch (type) {
+		case VSENTRY_IP_EVENT:
+			vsentry_print_ip_event(ev);
+			break;
+		case VSENTRY_CAN_EVENT:
+			vsentry_print_can_event(ev);
+			break;
+		case VSENTRY_FILE_EVENT:
+			vsentry_print_file_event(ev);
+			break;
+		default:
+			break;
+		}
+		cls_print_action(ev->act_bitmap);
+	}
+#endif
+
+#ifdef TIMECHECK
+	spin_unlock_irqrestore(&time_check_lock, flags);
+#endif
+
+	return ret;
+}
-- 
2.17.1

